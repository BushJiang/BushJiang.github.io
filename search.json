[{"title":"语义搜索效果差？试试重排","url":"/2025/01/15/语义搜索效果差？试试重排/","content":"\n前段时间我开发了一个用白话文搜索语义相近的古诗词的应用（详见： [如何假装文艺青年，怎么把大白话“变成”古诗词？](http://jiangjunqiao.top/2024/09/16/如何假装文艺青年，怎么把大白话“变成”古诗词？/)），但是有时候搜索结果却不让人满意，排名靠前的结果和查询的语义没啥关系，靠后的结果反而和查询更相似。比如，我用白话文“今天的雨好大”搜索，前三个结果是：\n\n>今日云景好，水绿秋山明。\n>今日风日好，明日恐不如。\n>雨落不上天，水覆难再收。\n\n前两个都和雨没有关系，第三个勉强沾边。\n\n为啥语义更相近的句子，反而排名靠后呢？主要有两个原因，一个是“不理解”，另一个是“难精确”。\n\n“不理解”和嵌入模型有关。我使用的嵌入模型可能训练语料中古诗词较少，导致它不能很好地“理解”古诗词的语义。\n\n“难精确”指的是不论你的度量方法使用的是余弦相似度（Cosine），还是欧几里得距离（L2），都不能保证语义最相似的结果一定排在第一。这些方法都是简化的模型，句子的语义内涵很难只用中学数学知识就能准确计算，只能说在整体趋势上，得分越高的结果语义和查询越接近。这就好像深圳入冬后，我们预测温度在10-20°C 之间，这样的预测整体来说是正确的，但是具体到每一天的温度就不一定准确了，可能有那么一两天，温度升到了25°C。\n\n这样的预测相当于语义搜索中的初步搜索，叫做“粗排”。想要优化搜索结果，重新排名，还需要“重排”，也就是 rerank。\n\n除此之外，还有一种情况下也需要重排，那就是混合搜索。我在 [门外汉如何“冒充”专家？向量嵌入之稀疏向量](http://jiangjunqiao.top/2024/12/11/门外汉如何“冒充”专家？向量嵌入之稀疏向量/) 这篇文章中介绍了稀疏向量，稠密向量和稀疏向量各有优势，怎么各取所长呢？可以先分别搜索（也就是混合搜索），再用搜索结果综合起来，而重排就是一种综合多种搜索结果的方法。\n\n这两种重排有所区别，第一种是基于深度学习的重排，第二种是基于统计的重排。第二种原理更简单，我们先来了解第二种。[^1] \n\n>本文首发于 Zilliz 公众号。文中代码的 Notebook 在[这里](https://pan.baidu.com/s/15z5hYqnuH3jXqUsYEcQO8g?pwd=jg5y)下载。\n\n## 基于统计的重排\n基于统计的重排用于混合搜索，它可以把多种搜索结果综合起来，重新排序。除了前面介绍的稠密向量和稀疏向量，还可以综合文本向量和图片向量。\n\n怎么综合呢？有两种方法，一种是 WeightedRanker ——分数加权平均算法，通过设置权重计算得分，后面简称权重策略。另一种是 RRFRanker（Reciprocal Rank Fusion）——逆序排名融合算法，通过排名的倒数来计算得分，后面简称 RRF 策略。\n\n### 权重策略\n权重策略就是设置权重。权重值范围从0到1，数值越大表示重要性越大。计算方法很简单，初始得分乘以权重，就是最终得分。[^2]\n\n$$\\text{WeightedRanker\\_score} = \\sum_{i=1}^{N} (w_i \\times \\text{score\\_n}_i) $$\n\n打个比方，假设某班级考了语文和数学两门课，统计出学生每门科目的分数和排名。学生就相当于向量数据库中的文档，学生这两门课的分数，就相当于文档在不同搜索结果中的得分。\n\n假设学生的成绩如下表所示：\n\n| 学生编号 | 数学成绩 | 语文成绩 |\n| ---- | ---- | ---- |\n| S1   | 100  | 50   |\n| S2   | 95   | 55   |\n| S3   | 80   | 70   |\n| S4   | 65   | 85   |\n| S5   | 80   | 75   |\n| S6   | 75   | 80   |\n| S7   | 70   | 85   |\n| S8   | 65   | 80   |\n| S9   | 60   | 85   |\n| S10  | 55   | 95   |\n\n在权重策略下，综合得分公式为：\n$$score = 数学成绩 * 0.7 + 语文成绩 * 0.3$$\n根据公式计算出学生们的综合分数，排名如下：\n\n| 权重综合排名 | 权重综合得分 | 学生编号 | 数学成绩 | 语文成绩 |\n| ------ | ------ | ---- | ---- | ---- |\n| 1      | 85     | S1   | 100  | 50   |\n| 2      | 83     | S2   | 95   | 55   |\n| 3      | 78.5   | S5   | 80   | 75   |\n| 4      | 77     | S3   | 80   | 70   |\n| 5      | 76.5   | S6   | 75   | 80   |\n| 6      | 74.5   | S7   | 70   | 85   |\n| 7      | 71     | S4   | 65   | 85   |\n| 8      | 69.5   | S8   | 65   | 80   |\n| 9      | 67.5   | S9   | 60   | 85   |\n| 10     | 67     | S10  | 55   | 95   |\n\n### RRF 策略\nRRF 策略的计算方式稍微复杂一点：\n$$\\text{RRF\\_score}(d) = \\sum_{i=1}^{N} \\frac{1}{k + \\text{rank}_i (d)}$$\n\n公式中的 rank 是初始分数的排名，k 是平滑参数。从公式中可以看出，排名越靠前，rank 的值越小，综合得分越高。同时， k 的值越大，排名对分数的影响越小。\n\n我们使用 RRF 策略重新计算分数和排名。参数 k 一般为60，为方便演示，这里设为 10，公式变成：\n$$\\text{RRF\\_score}(d) = \\sum_{i=1}^{N} \\frac{1}{10 + \\text{rank}_i (d)}$$\n\nRRF 策略根据排名计算分数，所以我们先列出数学和语文的排名。\n数学成绩排名：\n\n| 数学排名 | 数学成绩 | 学生编号 |\n| ---- | ---- | ---- |\n| 1    | 100  | S1   |\n| 2    | 95   | S2   |\n| 3    | 80   | S3   |\n| 3    | 80   | S5   |\n| 5    | 75   | S6   |\n| 6    | 70   | S7   |\n| 7    | 65   | S8   |\n| 7    | 65   | S4   |\n| 9    | 60   | S9   |\n| 10   | 55   | S10  |\n\n语文成绩排名：\n\n| 语文排名 | 语文成绩 | 学生编号 |\n| ---- | ---- | ---- |\n| 1    | 95   | S10  |\n| 2    | 85   | S4   |\n| 2    | 85   | S7   |\n| 2    | 85   | S9   |\n| 5    | 80   | S6   |\n| 5    | 80   | S8   |\n| 7    | 75   | S5   |\n| 8    | 70   | S3   |\n| 9    | 55   | S2   |\n| 10   | 50   | S1   |\n\n接下来使用 RRF 策略计算综合得分，重新排名：\n\n| RRF 综合排名 | RRF 综合得分 | 学生编号 | 数学成绩 | 语文成绩 |\n| ------------ | ------------ | -------- | -------- | -------- |\n| 1            | 0.1458       | S7       | 70       | 85       |\n| 2            | 0.1421       | S4       | 65       | 85       |\n| 3            | 0.1409       | S1       | 100      | 50       |\n| 3            | 0.1409       | S10      | 55       | 95       |\n| 5            | 0.1359       | S2       | 95       | 55       |\n| 5            | 0.1359       | S9       | 60       | 85       |\n| 7            | 0.1357       | S5       | 80       | 75       |\n| 8            | 0.1334       | S6       | 75       | 80       |\n| 9            | 0.1325       | S3       | 80       | 70       |\n| 10           | 0.1255       | S8       | 65       | 80       |\n\n比较两个排名可以发现，在权重策略下，数学的权重较大，偏科学生 S1虽然语文只有50分，也能因为数学100分而排在第一名。而 RRF 策略注重的是各科的排名，而不是分数，所以 S1的数学虽然排名第一，但是语文排名第10，综合排名下降到第三。\n\n学生 S7 正好相反，在权重策略下，即使他语文得了85的高分，但是权重只占30%，而高权重的数学只得了70分，所以综合排名靠后，排在第六名。在 RRF 策略下，他的数学和语文排名分别是第六名和第二名，语文的高排名拉高了综合排名，上升到了第一名。\n\n通过比较两种策略的排名结果，我们发现了这样的规律，如果你更看重搜索结果的得分，就使用权重策略，你还可以通过调整权重来调整得分；如果你更看重搜索结果的排名，就使用RRF策略。\n\n## 基于深度学习的重排\n和基于统计的重排相比，基于深度学习的重排更加复杂，通常被称为 Cross-encoder Reranker，交叉编码重排，后面简称“重排模型”。\n\n粗排和重排模型有什么区别呢？粗排搜索速度更快，重排模型准确性更高。\n\n为什么粗排搜索速快？粗排使用的是双塔模型（Dual-Encoder），“双塔”指的是它有两个独立的编码器，分别把查询和文档向量化，然后通过计算向量之间的相似度（比如余弦相似度Cosine）搜索结果并且排序。双塔模型的优势在于搜索效率高，因为可以提前计算文档向量，搜索时只需要向量化查询即可。而重排模型则是在搜索时现场编码。就好比两个饭店，一个使用预制菜，一个现场热炒，上菜速度肯定不一样。\n\n重排模型的优势则是准确性高。它把查询和文档组成数据对后输入给编码器编码，然后给它们的相似程度打分，针对性强。这就相当于公司招聘人才，粗排是根据专业、学历和工作年限等几个指标快速筛选简历，挑选出多位候选者。重排则是通过面试详细了解候选者做过什么项目，遇到了什么挑战，解决了什么难题，然后判断他有多适合应聘的岗位（文档与查询有多相似）。\n\n\n![image.png|600](https://picgo233.oss-cn-hangzhou.aliyuncs.com/img/202501042343533.png)\n图片来源：自己画的\n\n所以，重排模型适合那些对回答准确性要求高的场景，比如专业知识库或者客服系统。不适合追求高响应速度和低成本的场景，比如网页搜索、电商，这种场景建议使用基于统计的重排。\n\n你还可以把粗排和重排模型结合起来。比如，先通过粗排筛选出10个候选结果，再用重排模型重新排名。既可以提高搜索速度，也能保证准确度。\n\n## 代码实践\n版本说明：\nMilvus 版本：>=2.5.0\npymilvus 版本：>=2.5.0\n\n接下来我们通过代码实践一下，看看这些重排方法实际效果到底如何。\n\n我们会使用“敏捷的狐狸跳过懒惰的狗。”作为查询，从下面10个句子中搜索出语义相似的句子。你可以先猜一猜，粗排、基于统计的重排以及基于深度学习的重排，哪个效果最好。\n\n文档：\n```json\n[\n\t{\"content\": \"灵活的狐跳过了懒散的犬。\"},\n\t{\"content\": \"一只敏捷的狐在公园里跳过了那只懒犬。\"},\n\t{\"content\": \"那只懈怠的犬正在大树下睡觉。\"},\n\t{\"content\": \"在公园里，那只棕色的狐狸正在跳。\"},\n\t{\"content\": \"犬跃过了狐。\"},\n\t{\"content\": \"树下有一个小池塘。\"},\n\t{\"content\": \"动物如狗和狐狸生活在公园里。\"},\n\t{\"content\": \"池塘靠近公园里的大树。\"},\n\t{\"content\": \"懒狗跳过了狐狸。\"},\n\t{\"content\": \"那只灵巧的狐狸轻松地跨过了那只懒散的狗。\"},\n\t{\"content\": \"狐迅速地跳过了那只不活跃的犬。\"}\n]\n```\n\n首先创建集合。我们为集合设置稠密向量“dense_vectors”和稀疏向量“sparse_vectors”两个字段，分别储存稠密向量和稀疏向量，用于混合搜索。\n\n```python\nfrom pymilvus import MilvusClient, DataType\nimport time\n\n# 检查并且删除同名集合\ndef check_and_drop_collection(collection_name):\n    if milvus_client.has_collection(collection_name):\n        print(f\"集合 {collection_name} 已经存在\")\n        try:\n            milvus_client.drop_collection(collection_name)\n            print(f\"删除集合：{collection_name}\")\n            return True\n        except Exception as e:\n            print(f\"删除集合时出现错误: {e}\")\n            return False\n    return True\n\n\n# 创建模式\ndef create_schema():\n    schema = milvus_client.create_schema(\n        auto_id=True,\n        enable_dynamic_field=True,\n        description=\"\"\n    )\n    schema.add_field(field_name=\"id\", datatype=DataType.INT64, is_primary=True, max_length=256)\n    schema.add_field(field_name=\"content\", datatype=DataType.VARCHAR, max_length=256)\n    schema.add_field(field_name=\"dense_vectors\", datatype=DataType.FLOAT_VECTOR, dim=1024)\n    schema.add_field(field_name=\"sparse_vectors\", datatype=DataType.SPARSE_FLOAT_VECTOR)\n    return schema\n\n\n# 创建集合\nimport time\ndef create_collection(collection_name, schema, timeout = 3):\n    # 创建集合\n    try:\n        milvus_client.create_collection(\n            collection_name=collection_name,\n            schema=schema,\n            shards_num=2\n        )\n        print(f\"开始创建集合：{collection_name}\")\n    except Exception as e:\n        print(f\"创建集合的过程中出现了错误: {e}\")\n        return False\n\n    # 检查集合是否创建成功\n    start_time = time.time()\n    while True:\n        if milvus_client.has_collection(collection_name):\n            print(f\"集合 {collection_name} 创建成功\")\n            return True\n        elif time.time() - start_time > timeout:\n            print(f\"创建集合 {collection_name} 超时\")\n            return False\n        time.sleep(1)\n\nclass CollectionDeletionError(Exception):\n    \"\"\"删除集合失败\"\"\"\n\n\n\ncollection_name = \"test_rank\"\nuri=\"http://localhost:19530\"\nmilvus_client = MilvusClient(uri=uri)\n\n# 如果无法删除集合，抛出异常\nif not check_and_drop_collection(collection_name):\n    raise CollectionDeletionError('删除集合失败')\nelse:\n    # 创建集合的模式\n    schema = create_schema()\n    # 创建集合并等待成功\n    create_collection(collection_name, schema)\n```\n\n然后，定义把文档向量化的函数。我们使用 bge_m3 生成稠密向量和稀疏向量。\n\n```python\nfrom tqdm import tqdm\nimport torch\nfrom pymilvus.model.hybrid import BGEM3EmbeddingFunction\n\n# 初始化嵌入模型的实例\ndef init_embedding_model():\n    # 检查是否有可用的CUDA设备\n    device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\n    # 根据设备选择是否使用fp16\n    use_fp16 = device.startswith(\"cuda\")\n    # 创建嵌入模型实例\n    bge_m3_ef = BGEM3EmbeddingFunction(\n        model_name=\"BAAI/bge-m3\",\n        device=device,\n        use_fp16=use_fp16\n    )\n    return bge_m3_ef\n\n\n# 把查询向量化\ndef vectorize_query(query, encoder):\n    # 验证参数是否符合要求\n    if not (isinstance(query, list) and all(isinstance(text, str) for text in query)):\n        raise ValueError(\"query必须为字符串列表。\")\n    return encoder.encode_queries(query)\n\n\n# 把文档向量化\ndef vectorize_docs(docs, encoder):\n    # 验证参数是否符合要求\n    if not (isinstance(docs, list) and all(isinstance(text, str) for text in docs)):\n        raise ValueError(\"docs必须为字符串列表。\")\n    return encoder.encode_documents(docs)\n\n\n# 初始化嵌入模型实例\nbge_m3_ef = init_embedding_model()\n```\n\n接下来，生成向量并且导入向量数据库。\n```python\nimport json\n\n# 把文件中的指定字段向量化\ndef vectorize_file(input_file_path, encoder, field_name):\n    with open(input_file_path, 'r', encoding='utf-8') as file:\n        data_list = json.load(file)\n        docs = [data[field_name] for data in data_list]\n    # 向量化文档\n    return vectorize_docs(docs, encoder), data_list\n\n\n# 把数据插入数据库\ndef insert_data(\n    collection_name: str,\n    data_list,\n    dense_vectors,\n    sparse_vectors,\n    batch_size: int = 1000):\n    # 定义默认稀疏向量，避免生成稀疏向量失败。元素值全为0，表示它在所有维度上都不重要\n    default_sparse_vector = {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0}\n\n    # 接收稠密向量和稀疏向量\n    for data, dense_vector, sparse_vector in zip(data_list, dense_vectors, sparse_vectors):\n        data['dense_vectors'] = dense_vector\n        # 如果稀疏向量为空，则使用默认稀疏向量，避免入库时报错\n        if sparse_vector is not None:\n            data['sparse_vectors'] = sparse_vector\n        else:\n            data['sparse_vectors'] = default_sparse_vector\n\n    # 分批入库\n    print(f\"正在将数据插入集合：{collection_name}\")\n    total_count = len(data_list)\n    with tqdm(total=total_count, desc=\"插入数据\") as progress_bar:\n        # 每次插入 batch_size 条数据\n        for i in range(0, total_count, batch_size):  \n            batch_data = data_list[i:i + batch_size]\n            res = milvus_client.insert(\n                collection_name=collection_name,\n                data=batch_data\n            )\n            progress_bar.update(len(batch_data))\n\n\ninput_file_path = \"docs_rank.json\"\nfield_name = \"content\"\nvectors, data_list = vectorize_file(input_file_path, bge_m3_ef, field_name)\ndocs_dense_vectors = vectors['dense']\ndocs_sparse_vectors = vectors['sparse']\ninsert_data(collection_name, data_list, docs_dense_vectors, docs_sparse_vectors)\n```\n\n数据入库后，为它们创建索引。因为数据库中同时包含了两个向量，所以使用混合搜索，需要分别创建稠密向量和稀疏向量的索引。\n\n```python\nindex_params = milvus_client.prepare_index_params()\n\n# 创建密集向量索引参数\nindex_params.add_index(\n    index_name=\"IVF_FLAT\",\n    field_name=\"dense_vectors\",\n    index_type=\"IVF_FLAT\",\n    metric_type=\"COSINE\",\n    params={\"nlist\": 128}\n)\n\n# 创建稀疏向量索引参数\nindex_params.add_index(\n    index_name=\"sparse\",\n    field_name=\"sparse_vectors\",\n    index_type=\"SPARSE_INVERTED_INDEX\",\n    # 目前仅支持IP\n    metric_type=\"IP\",\n    params={\"drop_ratio_build\": 0.2}\n)\n```\n\n加载集合。\n\n```python\nprint(f\"正在加载集合：{collection_name}\")\nmilvus_client.load_collection(collection_name=collection_name)\n\n# 验证加载状态\nprint(milvus_client.get_load_state(collection_name=collection_name))\n```\n\n为了实现混合搜索，还需要定义混合搜索函数。\n\n```python\n# 混合搜索\nfrom pymilvus import AnnSearchRequest, WeightedRanker, RRFRanker\n\ndef perform_hybrid_search(\n    collection_name, \n    query, \n    ranker,\n    output_fields,\n    limit_dense,\n    limit_sparse,\n    limit_hybrid\n    ):\n    # 获取查询的稠密向量和稀疏向量\n    query_vectors = vectorize_query(query, bge_m3_ef)\n    query_dense_vectors = [query_vectors['dense'][0]]\n    query_sparse_vectors = [query_vectors['sparse'][[0]]]\n    # 创建稠密向量的搜索参数\n    dense_search_params = {\n        # 查询向量\n        \"data\": query_dense_vectors,  \n        \"anns_field\": \"dense_vectors\",\n        \"param\": {\n            \"metric_type\": \"COSINE\",\n            \"params\": {\n                \"nprobe\": 16,\n                \"radius\": 0.1,\n                \"range_filter\": 1\n            }\n        },\n        \"limit\": limit_dense\n    }\n    # 创建稠密向量的搜索请求\n    dense_req = AnnSearchRequest(**dense_search_params)\n    \n    # 创建稀疏向量的搜索参数\n    sparse_search_params = {\n        \"data\": query_sparse_vectors,\n        \"anns_field\": \"sparse_vectors\",\n        \"param\": {\n            \"metric_type\": \"IP\",\n            \"params\": {\"drop_ratio_search\": 0.2}\n        },\n        \"limit\": limit_sparse\n    }\n    # 创建稀疏向量的搜索请求\n    sparse_req = AnnSearchRequest(**sparse_search_params)\n    # 执行混合搜索\n    start_time = time.time()\n    res = milvus_client.hybrid_search(\n        collection_name=collection_name,\n        reqs=[dense_req, sparse_req],\n        ranker = ranker,\n        limit=limit_hybrid,\n        output_fields=output_fields\n    )\n    end_time = time.time()\n    total_time = end_time - start_time\n    print(f\"搜索时间：{total_time:.3f}\")\n    return res\n```\n\n最后再定义一个打印函数，方便查看搜索结果。\n\n```python\ndef print_vector_results(res):   \n    for hits in res:\n        for hit in hits:\n            entity = hit.get(\"entity\")\n            print(f\"content: {entity['content']}\")\n            print(f\"distance: {hit['distance']:.4f}\")\n            print(\"-\"*50)\n        print(f\"数量：{len(hits)}\")\n```\n\n## 对比搜索结果\n准备工作就绪，先分别看下稠密向量和稀疏向量的搜索结果。在混合搜索的权重策略下，调整权重，一个设置1，另一个设置为0，就可以只查看一种搜索结果。\n\n```python\nquery = [\"敏捷的狐狸跳过懒惰的狗。\"]\nranker=WeightedRanker(1, 0)\noutput_fields = [\"content\"]\nlimit_dense = 10\nlimit_sparse = 10\nlimit_hybrid = 10\n\nres_dense = perform_hybrid_search(collection_name, query, ranker, output_fields, limit_dense, limit_sparse, limit_hybrid)\nprint_vector_results(res_dense)\n```\n\n稠密向量的搜索结果勉强及格，正确答案分别排在第一、第三、第四和第五。让人不满意的是，语义和查询完全相反的句子，却排在了第二和第六，而且前6个搜索结果的得分相差很小，区别不明显。\n\n另外，留意一下搜索时间是0.012秒，后面要和基于深度学习的重排做比较。\n\n```plaintext\n搜索时间：0.012\ncontent: 灵活的狐跳过了懒散的犬。\ndistance: 0.9552\n--------------------------------------------------\ncontent: 懒狗跳过了狐狸。\ndistance: 0.9444\n--------------------------------------------------\ncontent: 一只敏捷的狐在公园里跳过了那只懒犬。\ndistance: 0.9373\n--------------------------------------------------\ncontent: 那只灵巧的狐狸轻松地跨过了那只懒散的狗。\ndistance: 0.9366\n--------------------------------------------------\ncontent: 狐迅速地跳过了那只不活跃的犬。\ndistance: 0.9194\n--------------------------------------------------\ncontent: 犬跃过了狐。\ndistance: 0.9025\n--------------------------------------------------\ncontent: 在公园里，那只棕色的狐狸正在跳。\ndistance: 0.8456\n--------------------------------------------------\ncontent: 动物如狗和狐狸生活在公园里。\ndistance: 0.8303\n--------------------------------------------------\ncontent: 那只懈怠的犬正在大树下睡觉。\ndistance: 0.7702\n--------------------------------------------------\ncontent: 树下有一个小池塘。\ndistance: 0.7174\n--------------------------------------------------\n数量：10\n```\n\n调整权重，再来看看稀疏向量的结果。\n```python\nranker=WeightedRanker(0, 1)\nres_sparse = perform_hybrid_search(collection_name, query, ranker, output_fields, limit_dense, limit_sparse, limit_hybrid)\nprint_vector_results(res_sparse)\n```\n\n~~稀疏向量的搜索结果不太理想，第一个搜索结果是正确的，第二、第三个搜索结果和查询相差太大，另一个正确答案在第四位才出现。搜索时间是0.014秒，和稠密向量相当。~~\n\n稀疏向量的搜索结果就更差了，正确答案分别排在第二、第三、第六和第七。这是因为我特意用语义相近但是文本不同的词做了替换，比如用“犬”代替“狗”，“懈怠”代替“懒”，导致它们较难命中查询中的词，得分较低。如果你想了解稀疏向量是如何参与搜索并且计算得分的，可以看看 [门外汉如何“冒充”专家？向量嵌入之稀疏向量](http://jiangjunqiao.top/2024/12/11/门外汉如何“冒充”专家？向量嵌入之稀疏向量/) 这篇文章。\n\n搜索时间是0.014秒，和稠密向量相当。\n\n```plaintext\n搜索时间：0.014\ncontent: 懒狗跳过了狐狸。\ndistance: 0.5801\n--------------------------------------------------\ncontent: 那只灵巧的狐狸轻松地跨过了那只懒散的狗。\ndistance: 0.5586\n--------------------------------------------------\ncontent: 一只敏捷的狐在公园里跳过了那只懒犬。\ndistance: 0.5553\n--------------------------------------------------\ncontent: 在公园里，那只棕色的狐狸正在跳。\ndistance: 0.5502\n--------------------------------------------------\ncontent: 动物如狗和狐狸生活在公园里。\ndistance: 0.5476\n--------------------------------------------------\ncontent: 灵活的狐跳过了懒散的犬。\ndistance: 0.5441\n--------------------------------------------------\ncontent: 狐迅速地跳过了那只不活跃的犬。\ndistance: 0.5336\n--------------------------------------------------\ncontent: 犬跃过了狐。\ndistance: 0.5192\n--------------------------------------------------\ncontent: 那只懈怠的犬正在大树下睡觉。\ndistance: 0.5006\n--------------------------------------------------\ncontent: 树下有一个小池塘。\ndistance: 0.0000\n--------------------------------------------------\n数量：10\n```\n\n接下来是重点了，我们分别使用权重策略和 RRF 策略，看看重排后的结果如何。\n\n先来看看权重策略中，权重是如何影响综合得分的。我们给稠密向量设置更高的权重——0.8，稀疏向量的权重则设置为0.2。\n\n```python\nranker=WeightedRanker(0.8, 0.2)\nres_Weighted = perform_hybrid_search(collection_name, query, ranker, output_fields, limit_dense, limit_sparse, limit_hybrid)\nprint_vector_results(res_Weighted)\n```\n\n综合排名第一的结果“灵活的狐跳过了懒散的犬。”，在稠密向量中的得分是0.9552，排名也是第一，与第二名相差0.108。\n\n它在稀疏向量中的得分是0.5441，排名第六。虽然排名低，但是得分与第一名只差0.036分，而且权重只占0.2，对综合得分仍然是第一。因为稠密向量的权重高，综合排名基本和稠密向量的排名一致。\n\n搜索时间是0.022秒。\n\n```plaintext\n搜索时间：0.022\ncontent: 灵活的狐跳过了懒散的犬。\ndistance: 0.8730\n--------------------------------------------------\ncontent: 懒狗跳过了狐狸。\ndistance: 0.8716\n--------------------------------------------------\ncontent: 那只灵巧的狐狸轻松地跨过了那只懒散的狗。\ndistance: 0.8610\n--------------------------------------------------\ncontent: 一只敏捷的狐在公园里跳过了那只懒犬。\ndistance: 0.8609\n--------------------------------------------------\ncontent: 狐迅速地跳过了那只不活跃的犬。\ndistance: 0.8423\n--------------------------------------------------\ncontent: 犬跃过了狐。\ndistance: 0.8259\n--------------------------------------------------\ncontent: 在公园里，那只棕色的狐狸正在跳。\ndistance: 0.7865\n--------------------------------------------------\ncontent: 动物如狗和狐狸生活在公园里。\ndistance: 0.7738\n--------------------------------------------------\ncontent: 那只懈怠的犬正在大树下睡觉。\ndistance: 0.7163\n--------------------------------------------------\ncontent: 树下有一个小池塘。\ndistance: 0.5739\n--------------------------------------------------\n数量：10\n```\n\n接下来，我们来看看权重策略下的第一名，在 RRF 策略中表现如何。\n\n```python\nranker = RRFRanker(k=10)\nres_rrf = perform_hybrid_search(collection_name, query, ranker, output_fields, limit_dense, limit_sparse, limit_hybrid)\nprint_vector_results(res_rrf)\n```\n\n“灵活的狐跳过了懒散的犬。”在 RRF 策略中的排名从第一下滑到了第四。因为这次注重的是排名，它在稠密向量中虽然排名第一，但是在稀疏向量中的排名只有第六，拉低了综合排名。\n\n排名第一是“懒狗跳过了狐狸。”，因为它在两个搜索结果中的排名都很高，分别是第二和第一。\n\n搜索时间是0.022秒，和权重策略的搜索时间差不多。\n\n```plaintext\n搜索时间：0.022\ncontent: 懒狗跳过了狐狸。\ndistance: 0.1742\n--------------------------------------------------\ncontent: 那只灵巧的狐狸轻松地跨过了那只懒散的狗。\ndistance: 0.1548\n--------------------------------------------------\ncontent: 一只敏捷的狐在公园里跳过了那只懒犬。\ndistance: 0.1538\n--------------------------------------------------\ncontent: 灵活的狐跳过了懒散的犬。\ndistance: 0.1534\n--------------------------------------------------\ncontent: 在公园里，那只棕色的狐狸正在跳。\ndistance: 0.1303\n--------------------------------------------------\ncontent: 狐迅速地跳过了那只不活跃的犬。\ndistance: 0.1255\n--------------------------------------------------\ncontent: 动物如狗和狐狸生活在公园里。\ndistance: 0.1222\n--------------------------------------------------\ncontent: 犬跃过了狐。\ndistance: 0.1181\n--------------------------------------------------\ncontent: 那只懈怠的犬正在大树下睡觉。\ndistance: 0.1053\n--------------------------------------------------\ncontent: 树下有一个小池塘。\ndistance: 0.0500\n--------------------------------------------------\n数量：10\n```\n\n终于，轮到我们最期待的重排模型上场了。其实，因为返回的搜索结果数量和文档中的句子数量相同，对任何一个搜索结果重排，或者直接对文档重排，效果都是一样的。不过，为了和实际应用中的粗排、重排流程一致，我们还是对粗排结果重排，比如稀疏向量的搜索结果。\n\n首先，我们要以字符串列表的形式，获取稀疏向量的搜索结果，以满足重排模型的输入要求。\n\n```python\n# 获取稀疏向量的搜索结果\ndef get_init_res_list(res, field_name):\n    res_list = []\n    for hits in res:\n        for hit in hits:\n            entity = hit.get(\"entity\")\n            res_list.append(entity[field_name])\n    return res_list\n\n# 为了显示重排的效果，我们对搜索结果最差的稀疏向量做重排\ninit_res_list = get_init_res_list(res_sparse, field_name)\n```\n\n接下来，定义重排模型。这里使用的是 bge_m3的重排模型。\n```python\nfrom pymilvus.model.reranker import BGERerankFunction\n\n# 定义重排函数\nbge_rf = BGERerankFunction(\n    model_name=\"BAAI/bge-reranker-v2-m3\",\n    device=\"cpu\"\n)\n\ndef perform_reranking(query: str, documents: list, top_k: int = 10) -> list:\n    # 获取重排结果\n    start_time = time.time()\n    rerank_res = bge_rf(\n        # query参数是字符串\n        query=query[0],\n        # documents参数是字符串列表\n        documents=documents,\n        top_k=top_k,\n    )\n    end_time = time.time()\n    total_time = end_time - start_time\n    print(f\"搜索时间：{total_time:.3f}\")\n    \n    return rerank_res\n\ntop_k = 10\nrerank_res = perform_reranking(query, init_res_list, top_k)\n```\n\n前面我提到过重排模型会花更多的时间，我们先对比下时间。第一次使用重排模型花了3.2秒，后面再使用一般用时0.4秒，这可能是因为第一次需要加载重排模型到内存中，花的时间较多。所以我们按照用时0.4秒计算。\n\n基于统计的重排用时在0.014-0.022秒之间，按照最慢的0.022秒计算。两者时间相差18倍。\n\n重排模型多花了这么多时间，效果怎么样呢？打印搜索结果看看吧。\n\n```python\nfor hit in rerank_res:\n    print(f\"content: {hit.text}\")\n    print(f\"score: {hit.score:.4f}\")\n    print(\"-\"*50)\n```\n\n我对重排结果还是比较满意的。四个正确答案排在前四名，而且得分非常接近满分1分。而且，它们和其他搜索结果在得分上终于拉开了较大的差距。\n\n```plaintext\ncontent: 灵活的狐跳过了懒散的犬。\nscore: 0.9998\n--------------------------------------------------\ncontent: 狐迅速地跳过了那只不活跃的犬。\nscore: 0.9997\n--------------------------------------------------\ncontent: 那只灵巧的狐狸轻松地跨过了那只懒散的狗。\nscore: 0.9987\n--------------------------------------------------\ncontent: 一只敏捷的狐在公园里跳过了那只懒犬。\nscore: 0.9980\n--------------------------------------------------\ncontent: 犬跃过了狐。\nscore: 0.3730\n--------------------------------------------------\ncontent: 懒狗跳过了狐狸。\nscore: 0.2702\n--------------------------------------------------\ncontent: 在公园里，那只棕色的狐狸正在跳。\nscore: 0.1924\n--------------------------------------------------\ncontent: 动物如狗和狐狸生活在公园里。\nscore: 0.0972\n--------------------------------------------------\ncontent: 那只懈怠的犬正在大树下睡觉。\nscore: 0.0059\n--------------------------------------------------\ncontent: 树下有一个小池塘。\nscore: 0.0000\n--------------------------------------------------\n```\n\n## 总结\n通过对比我们发现，基于统计的重排速度快，准确性一般，适合追求高响应速度和低成本的场景，比如网页搜索、电商。\n\n它有权重和 RRF 两个策略。如果你更看重某种类型的搜索结果，建议使用权重策略。如果你没有明显的偏好，希望在不同搜索结果中，排名都靠前的结果能够胜出，建议使用 RRF 策略。\n\n基于深度学习的重排速度慢，但是准确性高，适合对回答准确性要求高的场景，比如专业知识库或者客服系统。\n\n## 藏宝图\n如果你还想了解更多重排的知识，可以参考下面的文章：\n- [提高 RAG 应用准确度，时下流行的 Reranker 了解一下？](https://zilliz.com.cn/blog/rag-reranker-therole-and-tradeoffs)\n-  [一文玩转 Milvus 新特性之 Hybrid Search](https://mp.weixin.qq.com/s/t_ybJrc_Dhi5keIsgqy1vg)\n- [Rerankers Overview](https://milvus.io/docs/rerankers-overview.md)\n- [BGE 重排模型-github](https://github.com/FlagOpen/FlagEmbedding/tree/master/FlagEmbedding/llm_reranker#model-list)\n- [BGE重排模型在Milvus中的使用](https://milvus.io/docs/rerankers-bge.md)\n-  [Cross Encoder 重排模型在 Milvus 中的使用](https://milvus.io/docs/rerankers-cross-encoder.md)\n\n## 参考\n[^1]: [一文玩转 Milvus 新特性之 Hybrid Search](https://zilliz.com.cn/blog/Hybrid-Search)\n[^2]: [Reranking](https://milvus.io/docs/reranking.md#Weighted-Scoring-WeightedRanker)","categories":["向量数据库","原理探秘"]},{"title":"写给新读者的导航","url":"/2025/01/07/写给新读者的导航/","content":"\n你好啊朋友，我是江浩，一名AI大陆的探险者，目前主要关注向量数据库和大语言模型领域。\n\n在博客里，我会探秘AI神奇能力的背后原理。别担心，我会用有趣的言语和生动的类比来解释这些原理。你是否好奇，孙悟空 + 红楼梦 - 西游记 = ？那就来了解下向量嵌入吧。当你接触到向量嵌入后，你可能会问，既然已经有了稠密向量，为什么还需要稀疏向量？嗯，如果说稠密向量是领域专家，那么稀疏向量就是一个聪明的门外汉，面对领域外的知识，请教后者反而更合适。\n\n除了原理探秘，我还会用AI开发一些有趣的应用，比如，用白话文搜索语义相似的古诗词，让你体验一把“文艺青年”的乐趣。或者，开发一个“鲁迅说没有”的RAG应用，验证把所谓的“鲁迅名言”是否属实，它的原文又是怎样的。甚至，我还想和牛魔王对话，问问他更爱铁扇公主还是玉面狐狸。哈哈，有趣的想法太多，慢慢实现。\n\n对了，我在探索AI大陆时，也采集了不少鲜美的果实————优质资源，我会整理好了分享给你。\n\nAI大陆有趣又神奇，朋友，我邀请你和我同行。\n\nChangeLog\n2025-01-07","categories":["杂谈"]},{"title":"门外汉如何“冒充”专家？向量嵌入之稀疏向量","url":"/2024/12/11/门外汉如何“冒充”专家？向量嵌入之稀疏向量/","content":"\n在 [孙悟空 + 红楼梦 - 西游记 = ？向量嵌入之稠密向量](http://jiangjunqiao.top/2024/10/11/孙悟空-红楼梦-西游记-？向量嵌入之稠密向量/) 这篇文章中，我们已经知道了文本怎么变成稠密向量，并且还能够表达文本的语义。但是，对于嵌入模型的“专业领域”外的文本，它的效果不尽如人意。\n\n打个比方，假设你身体不舒服去看医生，医生完全理解你的描述，他会判断病因然后做出诊断。但是，如果你问医生“人工智能如何影响汽车行业？”，医生大概会觉得你不仅身体不舒服，脑子也需要治一治。医生不懂这方面的知识。\n\n想要获得答案，你可以去找人工智能或者汽车领域的专家。当然，你还有另一个选择，去找一位聪明的门外汉，“冒充”专家。\n\n>本文首发于 Zilliz 公众号。文中代码的 Notebook 在[这里](https://pan.baidu.com/s/1TCCz9KZelyNFgiUyPIvVnQ?pwd=9zh6)下载。\n\n## 聪明的门外汉——BM25\n稠密向量（Dense Vector）的维度较低，一般在几百到上千左右，每个维度的元素一般都不为零。相对的，还有一种稀疏向量（Sparse Vector），它的维度远远超过稠密向量，一般有几万甚至十万，但是大部分维度的元素都为零，只有少数元素是非零的。\n\n稀疏向量分成统计得到的稀疏向量和学习得到的稀疏向量两种，我们先聊聊第一种，代表就是 BM25。\n\nBM25 是一位聪明的门外汉，你问他领域外的知识，他虽然不理解，但是他会找到问题中的关键词，比如“人工智能”和“汽车”，然后去查文档，把文档中和关键词最相关的信息告诉你。\n\n那么，这位门外汉具体是怎么做的呢？\n\n首先，他会搜索成百上千篇相关文档，并且快速地翻一遍，了解这些文档中有哪些专业术语。什么样的词是专业术语呢？作为一个聪明的门外汉，他决定通过单词出现的频率判断。像“的”、“是”、“了”等常见词肯定不是专业术语，反而是那些出现频率比较低的词，更可能是专业术语。\n\n这就好比你有两个微信群，一个是工作群，平时消息不多，但是一旦有消息，不是领导布置任务，就是同事反馈进度，都很重要，你把这个群置顶了。\n\n另一个是吃喝玩乐群，一群朋友在群里聊天吹水，一整天消息不断，但是没那么重要，错过就错过了，忙的时候你还会设置成“信息免打扰”。\n\n对你来说，不同的群权重不同，门外汉也会为不同的词设置不同的权重。他会为文档中出现的词建立一个词汇表，并且根据单词出现的频率赋予权重，出现的频率越低，权重越大，越可能是专业术语。\n\n然后，他要判断哪些文档和“人工智能”以及“汽车”这两个专业术语更相关。他会对照词汇表，数一数每篇文档中这两个术语出现的频率，频率越高，相关性越大。\n\n以上是 BM25 的极简版解释，实际算法要复杂很多。公式越多，读者越少，所以下面我就简单介绍下 BM25 算法的工作原理。\n\n首先，BM25对文档集合做分词处理，得到一张词汇表。词汇表的单词（准确来说是 token）的数量，就是稀疏向量的维度。\n\n然后，对查询也做分词处理，比如，如果查询是“人工智能如何影响汽车行业？”，分词得到“人工智能“”、“影响”和“汽车行业”这三个词。\n\n接下来，计算**文档集合中的每个词**的逆文档频率 IDF，以及**查询中的某个词在指定文档**中的词频 TF。\n\n逆文档频率 IDF（Inverse Document Frequency），很绕口的一个名字。简单来说，它用来计算某个词在**文档集合**中出现的次数。出现次数越少，数值越大。门外汉用它给出现频率低的专业术语，赋予更大的权重。\n\n$$\n\\text{IDF}(q_i) = \\log \\left( \\frac{N - n(q_i) + 0.5}{n(q_i) + 0.5} \\right)\n$$\n\n其中：\n-  ${IDF}(q_i)$ 是单词 $q_i$ 的逆文档频率。\n-  $N$ 是文档总数。\n-  $n(q_i)$ 是语料库中，包含查询词 $(q_i)$ 的文档数量。\n-  $0.5$ 是一个平滑因子，用于避免分母为零的情况。\n\n\n词频TF（Term Frequency）表示查询中的某个词，在**指定文档**中出现的频率，频率越大数值越大，也就意味着查询和该文档的相关性更高。\n\n$$\n\\text{TF}(q_i, d) = \\frac{f(q_i, d) \\cdot (k_1 + 1)}{f(q_i, d) + k_1 \\cdot (1 - b + b \\cdot \\frac{|d|}{\\text{avgdl}})}\n$$\n其中：\n- ${TF}(q_i, d)$ 是查询词 $q_i$ 在文档 $d$ 中的词频。反映了查询词在文档中的重要性。\n-  $q$ 是查询。\n-  $d$ 是语料库中的某一个文档。\n-  $q_i$ 是查询中的第 $i$ 个 token。\n- $f (q_i, d)$ 是查询词 $q_i$ 在文档 $d$ 中出现的次数。\n-  $k_1$ ​ 是一个调节参数，用于控制词频的影响。 $k_1$ 取值在1.2到2之间\n- $b$ 是一个调节参数，用于控制文档长度对词频的影响。$b$ 取值为0.75。\n-  $|d|$ 是文档的长度。文档长度指的是分词后的 token 数量。\n-  ${avgdl}$ 是语料库中所有文档的平均长度。\n\n最后，根据 IDF 和 TF 计算 BM25分数，用来表示查询与指定文档的相关程度。\n\n$$\\text{BM25}(q, d) = \\sum_{i=1}^{n} \\text{IDF}(q_i) \\cdot \\text{TF}(q_i, d)$$\n\n## BM25 代码实践\n好啦，纸上谈兵到此结束，下面我们用代码实际操练一番吧。先做点准备工作。\n\n版本说明：\nMilvus 版本：>=2.5.0\npymilvus 版本：>=2.5.0\n\n假如下面的字符串列表就是我们的文档集合，每个字符串是一个文档：\n```plaintext\ndocs = [\n    \"机器学习正在改变我们的生活方式。\",\n    \"深度学习在图像识别中表现出色。\",\n    \"自然语言处理是计算机科学的重要领域。\",\n    \"自动驾驶依赖于先进的算法。\",\n    \"AI可以帮助医生诊断疾病。\",\n    \"金融领域广泛应用数据分析技术。\",\n    \"生产效率可以通过自动化技术提高。\",\n    \"机器智能的未来充满潜力。\",\n    \"大数据支持是机器智能发展的关键。\",\n    \"量子隧穿效应使得电子能够穿过经典力学认为无法穿过的势垒，这在半导体器件中有着重要的应用。\"\n]\n```\n\n使用BM25对第一个文档“机器学习正在改变我们的生活方式。”做分词处理：\n```python\nfrom pymilvus.model.sparse.bm25.tokenizers import build_default_analyzer\nfrom pymilvus.model.sparse import BM25EmbeddingFunction\n\n# 使用支持中文的分析器\nanalyzer = build_default_analyzer(language=\"zh\")\n\n# 分析器对文本做分词处理\ntokens1 = analyzer(docs[0])\nprint(tokens1)\n```\n\n分词结果如下：\n```plaintext\n['机器', '学习', '改变', '生活', '方式']\n```\n\n接下来对整个文档集合做分词处理，并且计算文档集合的 IDF 等参数：\n```python\n# 创建BM25EmbeddingFunction实例，传入分词器，以及其他参数\nbm25_ef = BM25EmbeddingFunction(analyzer)\n\n# 计算文档集合的参数\nbm25_ef.fit(docs)\n\n# 保存训练好的参数到磁盘以加快后续处理\nbm25_ef.save(\"bm25_params.json\")\n```\n\n我们看下参数有哪些内容：\n```python\nimport json\n\nfile_path = \"bm25_params.json\"\nwith open(file_path, 'r', encoding='utf-8') as file:\n    bm25_params = json.load(file)\n    print(bm25_params)\n```\n\n`corpus_size` 是文档数量，`avgdl`、`idf_value` 等参数都在前面的公式中出现过。\n```plaintext\n{'version': 'v1', 'corpus_size': 10, 'avgdl': 5.4, 'idf_word': ['机器', '学习', '改变', '生活', '方式', '深度', '图像识别', '中', '表现出色', '自然语言', '计算机科学', '领域', '自动', '驾驶', '依赖于', '先进', '算法', 'AI', '医生', '诊断', '疾病', '金融', '广泛应用', '数据分析', '技术', '生产', '效率', '自动化', '提高', '智能', '未来', '充满', '潜力', '大', '数据', '支持', '发展', '关键', '量子', '隧穿', '效应', '电子', '穿过', '经典力学', '势垒', '半导体器件'], 'idf_value': [0.7621400520468966, 1.2237754316221157, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.2237754316221157, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.2237754316221157, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.2237754316221157, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.2237754316221157, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331, 1.845826690498331], 'k1': 1.5, 'b': 0.75, 'epsilon'[^1]: 0.25}\n```\n\n `idf_word` 是 BM25对文档集合的分词结果，也就是前面提到的词汇表。词汇表中单词的数量，也是稀疏向量的维度。\n```python\n# BM25词汇表中的单词数量\nprint(f\"BM25词汇表中的单词数量：{len(bm25_params['idf_word'])}\")\n\n# BM25稀疏向量的维度\nprint(f\"BM25稀疏向量维度：{bm25_ef.dim}\")\n```\n\n返回的结果：\n```plaintext\nBM25词汇表中的单词数量：46\nBM25稀疏向量维度：46\n```\n\n需要的参数计算好了，接下来就可以生成文档集合的稀疏向量了。文档集合中有10篇文档，也就是10个字符串，而稀疏向量的维度是46，所以文档集合的稀疏向量是一个10行46列的矩阵。每一行表示一个文档的稀疏向量。\n\n```python\n# 生成文档集合的稀疏向量\nsparse_vectors_bm25 = bm25_ef.encode_documents(docs)\n\n# 打印文档集合的稀疏向量\nprint(sparse_vectors_bm25)\n```\n\n输出结果：\n```plaintext\n  (0, 0)\t1.0344827586206897\n  (0, 1)\t1.0344827586206897\n  (0, 2)\t1.0344827586206897\n  (0, 3)\t1.0344827586206897\n  (0, 4)\t1.0344827586206897\n  :\t:\n  (9, 7)\t0.7228915662650603\n  (9, 38)\t0.7228915662650603\n  (9, 39)\t0.7228915662650603\n  (9, 40)\t0.7228915662650603\n  (9, 41)\t0.7228915662650603\n  (9, 42)\t1.1214953271028039\n  (9, 43)\t0.7228915662650603\n  (9, 44)\t0.7228915662650603\n  (9, 45)\t0.7228915662650603\n```\n\n我们来看下第一个文档“机器学习正在改变我们的生活方式。”的稀疏向量：\n```python\n# 第一个文档的稀疏向量\nprint(list(sparse_vectors_bm25)[0])\n```\n\n结果为：\n```plaintext\n  (0, 0)\t1.0344827586206897\n  (0, 1)\t1.0344827586206897\n  (0, 2)\t1.0344827586206897\n  (0, 3)\t1.0344827586206897\n  (0, 4)\t1.0344827586206897\n```\n\n你发现了吧，第一个文档的稀疏向量只有5个非零元素，因为它的分词结果是5个单词，对应上了。而且，每个元素的值都相同，说明它们的逆文档频率 IDF 和词频 TF 都是一样的。\n\n第一个文档的分词结果：\n```plaintext\n['机器', '学习', '改变', '生活', '方式']\n```\n\n文档集合处理好了，我们再给出一个查询的句子，就可以执行搜索了。\n```python\nquery = [\"自动驾驶如何影响汽车行业？\"]\n\n# 把查询文本向量化\nquery_sparse_vectors_bm25 = bm25_ef.encode_queries(query)\n\n# 打印稀疏向量\nprint(query_sparse_vectors_bm25)\n\n# 查询的分词结果\nprint(analyzer(query[0]))\n```\n\n查看查询的稀疏向量，以及它的分词结果。\n```plaintext\n  (0, 12)\t1.845826690498331\n  (0, 13)\t1.845826690498331\n['自动', '驾驶', '影响', '汽车行业']\n```\n\n你可能会有疑问，为什么查询分词后得到4个单词，但是它的稀疏向量只有2维？因为这4个单词中，词汇表中只有“自动”和“驾驶”，没有“影响”和“汽车行业”，后两个词的 BM25 分数为0。\n\n哎，毕竟是门外汉啊。\n\n## 刚入门的新人——splade\n如果说稠密向量是精通特定领域的专家，统计得到的稀疏向量 BM25是聪明的门外汉，那么学习得到的稀疏向量 splade 就是刚入门的新人。他理解领域内专业术语的语义，而且能够举一反三，增加更多语义相近的词，一起查找。但是他毕竟还是新人，并不精通，还是通过数专业术语出现的次数，找到最相关的文档。\n\n具体来说，splade 是这样工作的：\n首先，splade 先对句子分词，通过嵌入模型 BERT （BERT 相关内容详见 [02-孙悟空 + 红楼梦 - 西游记 = ？向量嵌入之稠密向量](http://jiangjunqiao.top/2024/10/11/孙悟空-红楼梦-西游记-？向量嵌入之稠密向量/)）得到单词的向量。向量可以表达语义，所以 splade 能够“举一反三”，找到更多语义相似的单词。\n\n比如，对于“人工智能如何影响汽车行业”这个句子，分词得到“人工智能”和“汽车”两个 单词，以及与“人工智能”相似的“AI”等单词。\n\nsplade 也有一张词汇表，不过它不需要像 bm25 那样根据文档集合统计，而是预先就有的，来源于 BERT。\n\n接下来，splade 生成这些单词的稀疏向量。它会计算每个单词出现在词汇表中的每个位置的概率。也就是说，单词和词汇表中某个位置的词在语义上越接近，计算得到的概率越大。这个概率就是单词的权重。\n\n以“人工智能”为例，假设词汇表中第5个词也是“人工智能”，两个词完全一样，计算得到的概率就很高，比如40%。而词汇表第8个词是“机器学习”，两个词比较相似，概率是20%。而词汇表中其他的词和“人工智能”语义相差较远，概率很小，忽略不计。最后，“人工智能”的权重就是 $40\\% + 20\\% = 60\\%$。\n\n然后再用相同的方法，计算出“AI”和“汽车”的权重，得到稀疏向量：\n```python\nsparse_vector = {\"人工智能\": 0.6,\"AI\": 0.5,\"汽车\": 0.1}\n```\n\n## splade 代码实践\n老规矩，我们还使用代码验证下前面的内容。这次使用英文的文档集合：\n```plaintext\n# 使用英文\ndocs_en = [\n    \"Machine learning is changing our way of life.\",\n    \"Deep learning performs exceptionally well in image recognition.\",\n    \"Natural language processing is an important field in computer science.\",\n    \"Autonomous driving relies on advanced algorithms.\",\n    \"AI can help doctors diagnose diseases.\",\n    \"Data analysis technology is widely applied in the financial field.\",\n    \"Production efficiency can be improved through automation technology.\",\n    \"The future of machine intelligence is full of potential.\",\n    \"Big data support is key to the development of machine intelligence.\",\n    \"The quantum tunneling effect allows electrons to pass through potential barriers that classical mechanics consider impassable, which has important applications in semiconductor devices.\"\n]\n```\n\n生成文档集合的稀疏向量：\n```python\nfrom pymilvus.model.sparse import SpladeEmbeddingFunction\n\nquery_en = [\"How does artificial intelligence affect the automotive industry?\"]\n\nmodel_name = \"naver/splade-cocondenser-selfdistil\"\n\n# 实例化splade嵌入模型\nsplade_ef = SpladeEmbeddingFunction(\n    model_name = model_name, \n    device=\"cpu\"\n)\n\n# 生成文档集合的稀疏向量\nsparse_vectors_splade = splade_ef.encode_documents(docs_en)\nprint(sparse_vectors_splade)\n```\n\n和 BM25 一样，我们同样得到一个稀疏向量矩阵：\n```plaintext\n  (0, 1012)\t0.053256504237651825\n  (0, 2003)\t0.22995686531066895\n  (0, 2047)\t0.08765587955713272\n  :\t:\n  (9, 27630)\t0.2794925272464752\n  (9, 28688)\t0.02786295674741268\n  (9, 28991)\t0.12241243571043015\n```\n\nsplade 的词汇表是预先准备好的，词汇表中的单词数量同样也是稀疏向量的维度。\n```python\n# splade词汇表中的单词数量\nfrom transformers import AutoModelForMaskedLM, AutoTokenizer\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nprint(f\"splade词汇表中的单词数量：{tokenizer.vocab_size}\")\n\nprint(f\"splade稀疏向量维度：{splade_ef.dim}\")\n```\n\n二者相同：\n```plaintext\nsplade词汇表中的单词数量：30522\nsplade稀疏向量维度：30522\n```\n\n我们再来看看查询的分词结果及其稀疏向量：\n```python\n# 查看查询的分词\ntokens = tokenizer.tokenize(query_en[0])\nprint(f\"“{query_en[0]}” 的分词结果：\\n{tokens}\")\nprint(f\"tokens数量：{len(tokens)}\")\n\n# 生成查询的稀疏向量\nquery_sparse_vectors_splade = splade_ef.encode_queries(query_en)\nprint(query_sparse_vectors_splade)\n```\n\n结果如下：\n```plaintext\n“How does artificial intelligence affect the automotive industry?” 的分词结果：\n['how', 'does', 'artificial', 'intelligence', 'affect', 'the', 'automotive', 'industry', '?']\n\ntokens数量：9\n\n  (0, 2054)\t0.139632448554039\n  (0, 2079)\t0.08572433888912201\n  (0, 2106)\t0.22006677091121674\n  (0, 2126)\t0.038961488753557205\n  (0, 2129)\t0.6875206232070923\n  (0, 2138)\t0.5343469381332397\n  (0, 2194)\t0.32417890429496765\n  (0, 2224)\t0.011731390841305256\n  (0, 2339)\t0.33811360597610474\n  :\t:\n  (0, 26060)\t0.0731586366891861\n```\n\n比较分词的数量和稀疏向量的维度，你有没有发现有什么不对劲的地方？没错，分词数量和稀疏向量的维度不一样。这就是 splade 和 BM25的重要区别，splade 能够“举一反三”，它在最初9个分词的基础上，又增加了其他语义相近的单词。\n\n那么，查询现在一共有多少个单词呢？或者说，它的稀疏向量的非零元素有多少呢？\n```python\n# 获取稀疏向量的非零索引\nnonzero_indices = query_sparse_vectors_splade.indices[query_sparse_vectors_splade.indptr[0]:query_sparse_vectors_splade.indptr[1]]\n\n# 构建稀疏词权重列表\nsparse_token_weights = [\n    (splade_ef.model.tokenizer.decode(col), query_sparse_vectors_splade[0, col])\n    for col in nonzero_indices\n]\n\n# 按权重降序排序\nsparse_token_weights = sorted(sparse_token_weights, key=lambda item: item[1], reverse=True)\n\n# 查询句只有9个tokens，splade通过举一反三，生成的稀疏向量维度增加到了98个。\nprint(f\"splade 稀疏向量非零元素数量：{len(sparse_token_weights)}\")\n```\n\n一共有98个：\n```plaintext\nsplade 稀疏向量非零元素数量：98\n```\n\n具体是哪些单词？我们打印出来看一下：\n```python\n# 比如，和“artificial intelligence”语义相近的 “ai”，和“automotive”语义相近的“car”。\nfor token in sparse_token_weights:\n    print(token)\n```\n\nsplade 增加了大量语义相近的单词，比如和“artificial intelligence”语义相近的 “ai”，和“automotive”语义相近的“car”和“vehicle”。\n```plaintext\n('artificial', 2.588431)\n('intelligence', 2.3582284)\n('car', 1.590975)\n('automotive', 1.4835068)\n('vehicle', 0.798108)\n('ai', 0.676852)\n  :\t:\n```\n\n## 搜索实践\n我们已经了解了两种稀疏向量的特点，以及生成方法，下面就在搜索中体会下它们的区别吧。\n\n我们需要用 Milvus 创建集合，然后导入数据，创建索引，加载数据，就可以搜索了。这个过程我在 [如何假装文艺青年，怎么把大白话“变成”古诗词？](http://jiangjunqiao.top/2024/09/16/如何假装文艺青年，怎么把大白话“变成”古诗词？/) 中有详细介绍，就不多赘述了。\n\n创建集合。\n```python\nfrom pymilvus import MilvusClient, DataType\nimport time\n\n# 删除同名集合\ndef check_collection(collection_name):\n    if milvus_client.has_collection(collection_name):\n        print(f\"集合 {collection_name} 已经存在\")\n        try:\n            milvus_client.drop_collection(collection_name)\n            print(f\"删除集合：{collection_name}\")\n            return True\n        except Exception as e:\n            print(f\"删除集合时出现错误: {e}\")\n            return False\n    return True\n\n\n# 创建模式\ndef create_schema():\n    schema = milvus_client.create_schema(\n        auto_id=True,\n        enable_dynamic_field=True,\n        num_partitions=16,\n        description=\"\"\n    )\n    # 添加字段到schema\n    schema.add_field(field_name=\"id\", datatype=DataType.INT64, is_primary=True, max_length=256)\n    schema.add_field(field_name=\"text\", datatype=DataType.VARCHAR, max_length=256)\n    # bm25稀疏向量\n    schema.add_field(field_name=\"sparse_vectors_bm25\", datatype=DataType.SPARSE_FLOAT_VECTOR)\n    # splade稀疏向量\n    schema.add_field(field_name=\"sparse_vectors_splade\", datatype=DataType.SPARSE_FLOAT_VECTOR)\n    return schema\n\n\n# 创建集合\ndef create_collection(collection_name, schema, timeout = 3):\n    # 创建集合\n    try:\n        milvus_client.create_collection(\n            collection_name=collection_name,\n            schema=schema,\n            shards_num=2\n        )\n        print(f\"开始创建集合：{collection_name}\")\n    except Exception as e:\n        print(f\"创建集合的过程中出现了错误: {e}\")\n        return False\n\n    # 检查集合是否创建成功\n    start_time = time.time()\n    while True:\n        if milvus_client.has_collection(collection_name):\n            print(f\"集合 {collection_name} 创建成功\")\n            return True\n        elif time.time() - start_time > timeout:\n            print(f\"创建集合 {collection_name} 超时\")\n            return False\n        time.sleep(1)\n\n\n# 定义删除集合失败的异常类\nclass CollectionDeletionError(Exception):\n    \"\"\"删除集合失败\"\"\"\n\ncollection_name = \"docs\"\nuri=\"http://localhost:19530\"\nmilvus_client = MilvusClient(uri=uri)\ncheck_collection(collection_name)\n\n# 检查并删除同名集合\nif not check_collection(collection_name):\n    # 无法删除集合，抛出异常\n    raise CollectionDeletionError('删除集合失败')\nelse:\n    # 创建集合的模式\n    schema = create_schema()\n    # 创建集合并等待成功\n    create_collection(collection_name, schema)\n```\n\n导入数据。\n```python\n# 准备数据\nentities = [\n    {\n        # 文本字段\n        \"text\": docs[i],\n        \"text_en\": docs_en[i],\n        # bm25稀疏向量字段\n        \"sparse_vectors_bm25\": list(sparse_vectors_bm25)[i].reshape(1, -1),\n        # splade稀疏向量字段\n        \"sparse_vectors_splade\": list(sparse_vectors_splade)[i].reshape(1, -1),\n    }\n    for i in range(len(docs))\n]\n\n# 导入数据\nmilvus_client.insert(collection_name=collection_name, data=entities)\n```\n\n创建索引。\n```python\n# 创建索引参数\nindex_params = milvus_client.prepare_index_params()\n\n# 为稀疏向量bm25创建索引参数\nindex_params.add_index(\n    index_name=\"sparse_vectors_bm25\",\n    field_name=\"sparse_vectors_bm25\",\n    # SPARSE_INVERTED_INDEX是传统的倒排索引，SPARSE_WAND使用Weak-AND算法来减少搜索过程中的完整IP距离计算\n    index_type=\"SPARSE_INVERTED_INDEX\",\n    # 目前仅支持IP\n    metric_type=\"IP\",\n    # 创建索引时，排除向量值最小的20%的向量。对于稀疏向量来说，向量值越大，说明在该维度上的重要性越大。范围[0,1]。\n    params={\"drop_ratio_build\": 0.2}\n)\n\n\n# 为稀疏向量splade创建索引参数\nindex_params.add_index(\n    index_name=\"sparse_vectors_splade\",\n    field_name=\"sparse_vectors_splade\",\n    # SPARSE_INVERTED_INDEX是传统的倒排索引，SPARSE_WAND使用Weak-AND算法来减少搜索过程中的完整IP距离计算\n    index_type=\"SPARSE_INVERTED_INDEX\",\n    # 目前仅支持IP\n    metric_type=\"IP\",\n    # 创建索引时，排除向量值最小的20%的向量。对于稀疏向量来说，向量值越大，说明在该维度上的重要性越大。范围[0,1]。\n    params={\"drop_ratio_build\": 0.2}\n)\n\n# 创建索引\nmilvus_client.create_index(\n    collection_name=collection_name,\n    index_params=index_params\n)\n```\n\n查看索引是否创建成功。\n```python\n# 查看索引信息\ndef show_index_info(collection_name: str) -> None:\n    \"\"\"\n    显示指定集合中某个索引的详细信息。\n\n    参数:\n    collection_name (str): 集合的名称。\n\n    返回:\n    None: 该函数仅打印索引信息，不返回任何值。\n    \"\"\"\n    # 查看集合的所有索引\n    indexes = milvus_client.list_indexes(\n        collection_name=collection_name  \n    )\n    print(f\"已经创建的索引：{indexes}\")\n    print()\n    # 查看索引信息\n    if indexes:\n        for index in indexes:\n            index_details = milvus_client.describe_index(\n                collection_name=collection_name,  \n                # 指定索引名称，这里假设使用第一个索引\n                index_name=index\n            )\n            print(f\"索引 {index} 详情：{index_details}\")\n            print()\n    else:\n        print(f\"集合 {collection_name} 中没有创建索引。\")\n\n# 示例\nshow_index_info(collection_name)\n```\n\n如果创建成功，你会看到下面的输出：\n```plaintext\n已经创建的索引：['sparse_vectors_bm25', 'sparse_vectors_splade']\n\n索引 sparse_vectors_bm25 详情：{'drop_ratio_build': '0.2', 'index_type': 'SPARSE_INVERTED_INDEX', 'metric_type': 'IP', 'field_name': 'sparse_vectors_bm25', 'index_name': 'sparse_vectors_bm25', 'total_rows': 0, 'indexed_rows': 0, 'pending_index_rows': 0, 'state': 'Finished'}\n\n索引 sparse_vectors_splade 详情：{'drop_ratio_build': '0.2', 'index_type': 'SPARSE_INVERTED_INDEX', 'metric_type': 'IP', 'field_name': 'sparse_vectors_splade', 'index_name': 'sparse_vectors_splade', 'total_rows': 0, 'indexed_rows': 0, 'pending_index_rows': 0, 'state': 'Finished'}\n```\n\n加载集合。\n```python\n# 加载集合\nprint(f\"正在加载集合：{collection_name}\")\nmilvus_client.load_collection(collection_name=collection_name)\n\n# 验证加载状态\nprint(milvus_client.get_load_state(collection_name=collection_name))\n```\n\n如果加载成功，会显示：\n```plaintext\n正在加载集合：docs\n{'state': <LoadState: Loaded>}\n```\n\n加载完成，下面就是重头戏了，搜索。\n\n定义搜索函数：\n```python\n# 定义稀疏向量搜索参数\nsearch_params_sparse_vectors = {\n    \"metric_type\": \"IP\",\n    \"params\": {\"drop_ratio_search\": 0.2},\n}\n\n# 执行向量搜索\ndef vector_search(\n        query_vectors,\n        field_name,\n        search_params,\n        output_fields,\n    ):\n    # 向量搜索\n    res = milvus_client.search(\n        collection_name=collection_name,\n        # 指定查询向量。\n        data=query_vectors,\n        # 指定要搜索的向量字段\n        anns_field=field_name,\n        # 设置搜索参数\n        search_params=search_params,\n        output_fields=output_fields\n    )\n    return res\n```\n\n再定义一个打印结果的函数，方便查看结果。\n```python\n# 打印向量搜索结果\ndef print_vector_results(res):\n    for hits in res:\n        for hit in hits:\n            entity = hit.get(\"entity\")\n            print(f\"text: {entity['text']}\")\n            print(f\"distance: {hit['distance']:.3f}\")\n            print(\"-\"*50)\n        print(f\"数量：{len(hits)}\")\n```\n\n首先，我们使用 BM25搜索。\n```python\n# 使用稀疏向量BM25搜索\nquery1 = [\"人工智能如何影响汽车行业？\"]\n\nquery_sparse_vectors_bm25 = bm25_ef.encode_queries(query1)\n\nfield_name = \"sparse_vectors_bm25\"\noutput_fields = [\"text\"]\n# 指定搜索的分区，或者过滤搜索\nres_sparse_vectors_bm25 = vector_search(query_sparse_vectors_bm25, field_name, search_params_sparse_vectors, output_fields)\n\nprint_vector_results(res_sparse_vectors_bm25)\n```\n\n但是并没有搜索到任何结果：\n```plaintext\n数量：0\n```\n\n为什么呢？我们查看下 query1的分词结果：\n```python\n# 查看query1的分词结果\nprint(analyzer(query1[0]))\n```\n\n分词结果只有“人工智能”一个词：\n```plaintext\n['人工智能', '影响', '汽车行业']\n```\n\nBM25的词汇表中虽然有“智能”这个词，但是并不包含“人工智能”、“影响”和“汽车行业”这些词，所以没有返回任何结果。\n\n我们把“人工智能”替换成“机器智能”，就可以搜索到了。\n```python\n# 使用稀疏向量BM25搜索\nquery2 = [\"机器智能如何影响汽车行业？\"]\n\nquery_sparse_vectors_bm25 = bm25_ef.encode_queries(query2)\n\nfield_name = \"sparse_vectors_bm25\"\noutput_fields = [\"text\"]\n# 指定搜索的分区，或者过滤搜索\nres_sparse_vectors_bm25 = vector_search(query_sparse_vectors_bm25, field_name, search_params_sparse_vectors, output_fields)\n\nprint_vector_results(res_sparse_vectors_bm25)\n```\n\n而且，这次还搜索到了包含“机器学习”的句子。\n```plaintext\ntext: 机器智能的未来充满潜力。\ndistance: 2.054\n--------------------------------------------------\ntext: 大数据支持是机器智能发展的关键。\ndistance: 1.752\n--------------------------------------------------\ntext: 机器学习正在改变我们的生活方式。\ndistance: 0.788\n--------------------------------------------------\n数量：3\n```\n\n这是因为分词时把“机器智能“分成了“机器”和“智能”两个词，所以能搜索到更多句子。\n```python\n# 查看query2的分词结果\nprint(analyzer(query2[0]))\n```\n\n分词结果：\n```plaintext\n['机器', '智能', '影响', '汽车行业']\n```\n\n接下来，我们使用 splade 搜索，看看和 BM25的搜索结果有什么不同。\n\n先定义一个打印结果的函数。\n```python\n# 打印向量搜索结果\ndef print_vector_results_en(res):\n    for hits in res:\n        for hit in hits:\n            entity = hit.get(\"entity\")\n            print(f\"text_en: {entity['text_en']}\")\n            print(f\"distance: {hit['distance']:.3f}\")\n            print(\"-\"*50)\n        print(f\"数量：{len(hits)}\")\n```\n\n然后使用 splade 搜索。\n```python\nquery1_en = [\"How does artificial intelligence affect the automotive industry?\"]\n\nquery_sparse_vectors_splade = splade_ef.encode_queries(query1_en)\n\nfield_name = \"sparse_vectors_splade\"\noutput_fields = [\"text_en\"]\nres_sparse_vectors_splade = vector_search(query_sparse_vectors_splade, field_name, search_params_sparse_vectors, output_fields)\n\nprint_vector_results_en(res_sparse_vectors_splade)\n```\n\n比较 BM25 和 splade 的搜索结果，我们很容易发现它们之间的区别。splade 的文档集合中并不包含“artificial intelligence”这个词，但是由于它具有“举一反三”的能力，仍然搜索到了包含“AI”、“machine intelligence”以及“Autonomous”的句子，返回了更多结果（其实是返回了所有文档）。\n\n```plaintext\ntext_en: The future of machine intelligence is full of potential.\ndistance: 10.020\n--------------------------------------------------\ntext_en: Big data support is key to the development of machine intelligence.\ndistance: 8.232\n--------------------------------------------------\ntext_en: AI can help doctors diagnose diseases.\ndistance: 7.291\n--------------------------------------------------\ntext_en: Autonomous driving relies on advanced algorithms.\ndistance: 7.213\n--------------------------------------------------\ntext_en: Production efficiency can be improved through automation technology.\ndistance: 6.999\n--------------------------------------------------\ntext_en: Machine learning is changing our way of life.\ndistance: 6.863\n--------------------------------------------------\ntext_en: Data analysis technology is widely applied in the financial field.\ndistance: 5.064\n--------------------------------------------------\ntext_en: The quantum tunneling effect allows electrons to pass through potential barriers that classical mechanics consider impassable, which has important applications in semiconductor devices.\ndistance: 3.695\n--------------------------------------------------\ntext_en: Deep learning performs exceptionally well in image recognition.\ndistance: 3.464\n--------------------------------------------------\ntext_en: Natural language processing is an important field in computer science.\ndistance: 3.044\n--------------------------------------------------\n数量：10\n```\n\n如果把查询中的“artificial intelligence”替换成“machine intelligence”，仍然会返回所有结果，但是权重有所不同。\n\n```plaintext\ntext_en: The future of machine intelligence is full of potential.\ndistance: 15.128\n--------------------------------------------------\ntext_en: Big data support is key to the development of machine intelligence.\ndistance: 12.945\n--------------------------------------------------\ntext_en: Machine learning is changing our way of life.\ndistance: 12.763\n--------------------------------------------------\ntext_en: Production efficiency can be improved through automation technology.\ndistance: 7.446\n--------------------------------------------------\ntext_en: AI can help doctors diagnose diseases.\ndistance: 6.055\n--------------------------------------------------\ntext_en: Autonomous driving relies on advanced algorithms.\ndistance: 5.309\n--------------------------------------------------\ntext_en: Data analysis technology is widely applied in the financial field.\ndistance: 4.857\n--------------------------------------------------\ntext_en: The quantum tunneling effect allows electrons to pass through potential barriers that classical mechanics consider impassable, which has important applications in semiconductor devices.\ndistance: 3.356\n--------------------------------------------------\ntext_en: Deep learning performs exceptionally well in image recognition.\ndistance: 3.317\n--------------------------------------------------\ntext_en: Natural language processing is an important field in computer science.\ndistance: 2.688\n--------------------------------------------------\n数量：10\n```\n\n## 藏宝图\n如果你想深入研究稀疏向量，可以参考下面的资料：\n- [精通BM25：深入探讨算法及其在Milvus中的应用](https://zilliz.com.cn/blog/mastering-bm25-a-deep-dive-into-the-algorithm-and-application-in-milvu)\n- [详解如何通过稀疏向量优化信息检索]( https://mp.weixin.qq.com/s/ZvId2vm8PDdA1fW3hJY1bA )\n- [splade的github](https://github.com/naver/splade)\n-  [BM25-wiki](https://en.wikipedia.org/wiki/Okapi_BM25)\n\n## 注释\n[^1]: BM25公式中并没有 epsilon 这个参数。在模型中，它用于平滑处理，以避免除以零的情况，特别是在文档长度（dl）为零的情况下。epsilon 通常是一个小的正数，如0.5，它被加到文档长度的归一化公式中，确保公式的稳定性。","categories":["向量数据库","原理探秘"]},{"title":"鲁迅到底说没说？RAG之分块","url":"/2024/10/29/鲁迅到底说没说？RAG之分块/","content":"\n鲁迅说，“世上本没有路，走的人多了，也便成了路。”。\n鲁迅说，“我家墙外有两株树，一株是枣树，还有一株也是枣树。”\n鲁迅还说，“猛兽总是独行，牛羊才成群结对。”\n网络上流传着鲁迅说过的各种名言，我们不禁怀疑，鲁迅到底说没说？原文是什么样的，出处又在哪里？想回答这个问题，最好的办法就是搜索原文。但是，使用传统搜索方式，错了一个字可能就搜索不到，不如试试语义搜索吧。\n\n我们可以把鲁迅作品集向量化，储存到向量数据库中。然后搜索某条据说是鲁迅说过的话，最后通过大模型组织语言输出回答，告诉我们鲁迅有没有说过这句话。如果有，再让它附上原文和出处。这个过程，就是 RAG（Retrieval-Augmented Generation，检索增强生成）。\n\n而对于较长的本文，直接向量化会导致信息缺失，需要把文本分割成多个块，分别向量化。打个比方，如果一篇文章是一张图片，组成文章的块就是图片的像素点。文章分割成的块越多，意味着图片的像素点越多，分辨率越高，图片也就越清晰。我会介绍三种常见的分块方法，并且比较基于它们的向量搜索和 RAG 响应有什么区别。\n\n![](https://picgo233.oss-cn-hangzhou.aliyuncs.com/img/202410142156303.png)\n\n图片来源：Photo by [Master Unknown](https://unsplash.com/@exp00?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash) on [Unsplash](https://unsplash.com/photos/a-mountain-range-is-reflected-in-the-still-water-of-a-lake-Vyy3Nnlm5Uc?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)\n\n>本文首发于 Zilliz 公众号。文中代码的 Notebook 在[这里](https://pan.baidu.com/s/1i-KkIlePQtqhHflIeRx2jA?pwd=fcpb)下载。\n\n## 字数太多怎么向量化\n在 [如何假装文艺青年，怎么把大白话“变成”古诗词？](http://jiangjunqiao.top/2024/09/16/如何假装文艺青年，怎么把大白话“变成”古诗词？/) 这篇文章中，我详细介绍了使用 Milvus 创建向量数据库的整个过程，相关内容我就不再赘述了，直接给出代码。\n\n版本说明：\nMilvus 版本：>=2.5.0\npymilvus 版本：>=2.5.0\n\n定义函数 vectorize_query 把文本向量化的函数。\n```python\nimport torch\nfrom pymilvus.model.hybrid import BGEM3EmbeddingFunction\n\n# 初始化嵌入模型的实例\ndef init_embedding_model():\n    # 检查是否有可用的CUDA设备\n    device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\n    # 根据设备选择是否使用fp16\n    use_fp16 = device.startswith(\"cuda\")\n    # 创建嵌入模型实例\n    bge_m3_ef = BGEM3EmbeddingFunction(\n        model_name=\"BAAI/bge-m3\",\n        device=device,\n        use_fp16=use_fp16\n    )\n    return bge_m3_ef\n\n# 把文档向量化\ndef vectorize_docs(docs, encoder):\n    # 验证参数是否符合要求\n    if encoder is None:\n        raise ValueError(\"嵌入模型未初始化。\")\n    if not (isinstance(docs, list) and all(isinstance(text, str) for text in docs)):\n        raise ValueError(\"docs必须为字符串列表。\")\n    return encoder.encode_documents(docs)\n\nbge_m3_ef = init_embedding_model()\n```\n\n下一步就是把鲁迅作品集向量化了。但是且慢，让我们先看一下鲁迅作品集[^1]的文本格式：\n```json\n[ \n\t{\n\t\t\"book\": \"伪自由书\", \n\t\t\"title\": \"最艺术的国家\", \n\t\t\"author\": \"鲁迅\", \n\t\t\"type\": \"\", \n\t\t\"source\": \"\", \n\t\t\"date\": \"\", \n\t\t\"content\": \"我们中国的最伟大最永久，而且最普遍的“艺术”是男人扮女人... \n\t}, \n\t{\n\t\t\"book\": \"伪自由书\", \n\t\t\"title\": \"王道诗话\", \n\t\t\"author\": \"鲁迅\", \n\t\t\"type\": \"\", \n\t\t\"source\": \"\", \n\t\t\"date\": \"\", \n\t\t\"content\": \"《人权论》是从鹦鹉开头的，据说古时候有一只高飞远走的鹦哥儿... \n\t}, \n\t...\n]\n```\n\n文本中的“content”字段的值，就是一篇文章。有的文章字数多达几万字，用几百维的向量根本无法表达文章的语义细节。怎么办？就像前面说的，既然全文字数太多，我们就把文章切成几块，对每个块再做向量化。这个操作叫做“分块”。\n\n## 根据固定字数分块\n最简单的分块方法是 `fixed_chunk`（固定分块），是按照字数分块，比如每隔150个字就分割一次。比如，对于《最艺术的国家》这篇文章使用 `fixed_chunk`，再通过 [ChunkViz](https://chunkviz.up.railway.app/) 把分块结果可视化，如下图所示：\n![](https://picgo233.oss-cn-hangzhou.aliyuncs.com/img/202410082047910.png)\n\n我们用代码来实现 `fixed_chunk`。\n```python\nimport json\n\n# 固定分块\ndef fixed_chunk(\n    input_file_path,\n    output_file_path, \n    chunk_size, \n    field_name\n    ):\n    with open(input_file_path, 'r', encoding='utf-8') as file:\n        data_list = json.load(file)\n        chunk_data_list = []\n        for data in data_list:\n            # 获取指定字段的值\n            text = data[field_name]\n            # 对指定字段分割\n            chunks = [text[i:i + chunk_size] for i in range(0, len(text), chunk_size)]\n            for idx, chunk in enumerate(chunks):\n                chunk_data_list.append({\n                    # 使用原始文章的 id 生成chunk的id\n                    \"id\": f'{data[\"book\"]}#{data[\"title\"]}#chunk{idx}',\n                    \"book\" : data[\"book\"],\n                    \"title\" : data[\"title\"],\n                    \"chunk\" : chunk,\n                    # window 字段在这里只是占位，没有实际作用，后面会详细介绍它的用处\n                    \"window\": \"\",\n                    \"method\": \"fixed_chunk\"\n                })\n        with open(output_file_path, 'w', encoding='utf-8') as json_file:\n            json.dump(chunk_data_list, json_file, ensure_ascii=False, indent=4)\n\n# 执行固定分块的函数\ninput_file_path = \"luxun_sample.json\"\noutput_file_path = \"luxun_sample_fixed_chunk.json\"\nchunk_size = 150\nfield_name = \"content\"\n\nfixed_chunk(input_file_path, output_file_path, chunk_size, field_name)\n```\n\n运行代码，得到 `luxun_sample_fixed_chunk.json` 文件，格式和上文中的可视化结果一致。\n```plaintext\n[\n    {\n        \"id\": \"伪自由书 #最艺术的国家 #chunk0 \",\n        \"book\": \"伪自由书\",\n        \"title\": \"最艺术的国家\",\n        \"author\": \"鲁迅\",\n        \"type\": \"\",\n        \"source\": \"\",\n        \"date\": \"\",\n        \"chunk\": \"我们中国的最伟大最永久，而且最普遍的“艺术”是男人扮女人...\",\n        \"window\": \"\",\n        \"method\": \"fixed_chunk\"\n    },\n    {\n        \"id\": \"伪自由书 #最艺术的国家 #chunk1 \",\n        \"book\": \"伪自由书\",\n        \"title\": \"最艺术的国家\",\n        \"author\": \"鲁迅\",\n        \"type\": \"\",\n        \"source\": \"\",\n        \"date\": \"\",\n        \"chunk\": \"民国。然而这民国年久失修...\",\n        \"window\": \"\",\n        \"method\": \"fixed_chunk\"\n    },\n    ...\n]\n```\n\n你可能已经发现了，`fixed_chunk` 经常在句子中间分割，导致句子不连贯，语义的完整性被破坏。\n\n## 根据标点符号分割\n怎么解决这个问题呢？我们可以在标点符号处分割。但是这还不够，因为这样分割的话，块与块之间仍然是相互独立的了，缺少关联。打个比方，如果看《生活大爆炸》这样的单元剧，我们跳着看也没关系，不影响理解剧情。但是如果看《天龙八部》这样的连续剧，上一集讲的还是段誉为救钟灵去万劫谷拿解药，下一集他就瞬移到了少室山，用六脉神剑大战慕容复。我们会一头雾水，这中间到底发生了什么？\n\n所以，连续剧的开头有“前情提要”，结尾有“下集预告”。同样，为了保证块与块之间语义的连贯，我们也要设计一个“重叠”部分，让下一个块的开头部分，重复上一个块的结尾部分。\n\n听起来很复杂？不用担心，我们可以使用 LlamaIndex[^2] 库轻松实现这种分块方法—— `semantic_chunk` 。\n\n安装 LlamaIndex 库。\n```shell\npip install llama_index==0.11.16\n```\n\n定义 `semantic_chunk` 分块函数。\n```python\n# 导入SentenceSplitter用来分块\nfrom llama_index.core.node_parser import SentenceSplitter\n\ndef semantic_chunk(\n        input_file_path, \n        output_file_path, \n        # 块的大小\n        chunk_size,\n        # 重叠部分的大小\n        chunk_overlap,\n        # 指定分块的字段\n        field_name,\n        ) :\n    # 初始化 SentenceSplitter，设置分块的参数\n    text_splitter = SentenceSplitter(\n        # 指定段落分隔符\n        paragraph_separator=\"\\n\\n\\n\",\n        # 指定主要分隔符\n        separator=\"。\",\n        # 指定次要分隔符\n        secondary_chunking_regex=\"[^，.；、。：]+[，.；、。：]?\",\n        # 指定块的大小\n        chunk_size=chunk_size, \n        # 指定重叠部分的大小\n        chunk_overlap=chunk_overlap,\n    )\n    with open(input_file_path, 'r', encoding='utf-8') as file:\n        data_list = json.load(file)\n        chunk_data_list = []\n        for data in data_list:\n            text = data[field_name]\n            chunks = text_splitter.split_text(text)\n            for idx, chunk in enumerate(chunks):\n                chunk_data_list.append({\n                    # 使用原始文章的 id 生成chunk的id\n                    \"id\": f'{data[\"book\"]}#{data[\"title\"]}#chunk{idx}',\n                    \"book\" : data[\"book\"],\n                    \"title\" : data[\"title\"],\n                    \"chunk\" : chunk,\n                    # window 字段在这里只是占位，没有实际作用，后面会详细介绍它的用处\n                    \"window\": \"\",\n                    \"method\": \"semantic_chunk\"\n                })\n        with open(output_file_path, 'w', encoding='utf-8') as json_file:\n            json.dump(chunk_data_list, json_file, ensure_ascii=False, indent=4)\n\n# 执行标点符号分块\ninput_file_path = \"luxun_sample.json\"\noutput_file_path = \"luxun_sample_semantic_chunk.json\"\nchunk_size = 150\nchunk_overlap = 20\nfield_name = \"content\"\n\nsemantic_chunk(\n    input_file_path, \n    output_file_path, \n    chunk_size, \n    chunk_overlap,\n    field_name\n)\n```\n\n执行上面的代码，得到 `luxun_sample_semantic_chunk.json` 文件，我们来看一下分块的结果：\n\n```plaintext\n[\n    {\n        \"id\": \"伪自由书#最艺术的国家#chunk0\",\n        \"book\": \"伪自由书\",\n        \"title\": \"最艺术的国家\",\n        \"author\": \"鲁迅\",\n        \"type\": \"\",\n        \"source\": \"\",\n        \"date\": \"\",\n        \"chunk\": \"我们中国的最伟大最永久，而且最普遍的“艺术”是男人扮女人...中国的固有文化是科举制度，外加捐班之类。\",\n        \"window\": \"\",\n        \"method\": \"semantic_chunk\"\n    },\n    {\n        \"id\": \"伪自由书#最艺术的国家#chunk1\",\n        \"book\": \"伪自由书\",\n        \"title\": \"最艺术的国家\",\n        \"author\": \"鲁迅\",\n        \"type\": \"\",\n        \"source\": \"\",\n        \"date\": \"\",\n        \"chunk\": \"外加捐班之类。当初说这太不像民权...这对于民族是不忠，对于祖宗是不孝，\",\n        \"window\": \"\",\n        \"method\": \"semantic_chunk\"\n    },\n    ...\n]\n```\n\n果然是在我们设置的标点符号处分块的，而且附带重叠部分，这样就能保证块与块之间语义的连贯了。\n\n## 根据句子分块\n对于上面的分块结果，你可能还不满意。虽然它根据标点符号分割，但是并不一定在句号处分割，无法保证句子的完整性。比如，对于这句话 `我们中国的最伟大最永久，而且最普遍的“艺术”是男人扮女人。这艺术的可贵，是在于两面光，或谓之“中庸”---男人看见“扮女人”，女人看见“男人扮”。` 可能分割成 `我们中国的最伟大最永久，而且最普遍的“艺术”是男人扮女人。这艺术的可贵` 和 ` 是在于两面光，或谓之“中庸”---男人看见“扮女人”，女人看见“男人扮” ` 两个块。\n\n为了解决这个问题，又诞生了一种分块方法，它根据句子而不是字数分割，也就是说，根据“。”、“！”和“？”这三个表示句子结束的标点符号分割，而不会受到字数的限制。但是，这种分割方式怎么实现重叠的功能呢？这也简单，把整个句子作为重叠部分就行了，叫做“窗口句子”。这种分块方法叫做 `window_chunk`。\n\n比如，对于句子 `ABCD`，设置窗口大小为1，表示原始句子的左右各1个句子为“窗口句子”。分块如下：\n第一个句子：A。窗口句子：B。因为第一个句子的左边没有句子。\n第二个句子：B。窗口句子：A 和 C。\n第三个句子：C。窗口句子：B 和 D。\n第四个句子：D。窗口句子：C。因为最后一个句子的右边没有句子。\n\n前面两种分块方法，都是对 chunk 字段向量化。而这种分块方法，除了对 chunk 字段（也就是原始句子）向量化外，还会把窗口句子作为原始句子的上下文，以元数据的形式储存在文件中。\n\n原始句子用来做向量搜索，而在生成回答时，窗口句子和原始句子会一起传递给大模型。这样做的好处是，只向量化原始句子，节省了储存空间。提供窗口句子作为原始句子的上下文，可以帮助大模型理解原始句子的语境。\n\n理解原理了，我们用代码来实现吧。\n\n导入依赖。\n```python\n# 导入句子分块需要的依赖\nimport re\nfrom typing import List\nfrom llama_index.core import Document\nfrom llama_index.core.node_parser import SentenceWindowNodeParser\n```\n\n定义函数 `split_text_into_sentences`，用来分割中英文句子。\n```python\n# 分割中英文句子\ndef split_text_into_sentences(text):\n    # 使用正则表达式识别中英文句子结束符\n    sentence_endings = re.compile(r'(?<=[。！？.!?])')\n    sentences = sentence_endings.split(text)\n    return [s.strip() for s in sentences if s.strip()]\n```\n\n定义函数 `window_chunk`，基于句子对文本分块。\n```python\n# 根据句子对文本分块\ndef window_chunk(\n        input_file_path, \n        output_file_path,\n        field_name,\n        window_size\n    ):\n    # 设置用于文本解析的节点解析器\n    node_parser = SentenceWindowNodeParser.from_defaults(\n        window_size=window_size,\n        # 为窗口元数据指定一个键名为\"window\"，用于在解析过程中存储窗口数据\n        window_metadata_key=\"window\",\n        # 为原始文本元数据指定一个键名为\"original_text\"，用于在解析过程中存储原始文本\n        original_text_metadata_key=\"original_text\",\n        sentence_splitter = split_text_into_sentences\n    )\n    \n    with open(input_file_path, 'r', encoding='utf-8') as file:\n        data_list = json.load(file)\n        chunk_data_list = []\n        for data in data_list:\n            text = data[field_name]\n            # 将分割后的句子处理成节点。节点包含多个句子，类似于块\n            document = Document(text=text)\n            nodes = node_parser.get_nodes_from_documents([document])\n            for idx, node in enumerate(nodes):\n                chunk = node.metadata[\"original_text\"]\n                window = node.metadata[\"window\"]\n                chunk_data_list.append({\n                    \"id\": f'{data[\"book\"]}#{data[\"title\"]}#chunk{idx}',\n                    \"book\": data[\"book\"],\n                    \"title\": data[\"title\"],\n                    \"chunk\": chunk,\n                    \"window\": window,\n                    \"method\": \"window_chunk\"\n                })\n        \n        with open(output_file_path, 'w', encoding='utf-8') as json_file:\n            json.dump(chunk_data_list, json_file, ensure_ascii=False, indent=4)\n\n# 执行句子分块\ninput_file_path = \"luxun_sample.json\"\noutput_file_path = \"luxun_sample_window_chunk.json\"\nfield_name = \"content\"\nwindow_size = 1\n\nwindow_chunk(\n    input_file_path,\n    output_file_path,\n    field_name,\n    window_size\n)\n```\n\n让我们来看下分块的结果，字段“chunk”是原始句子，“window”里面包含了原始句子和窗口句子。\n```plaintext\n[\n    {\n        \"id\": \"伪自由书#最艺术的国家#chunk0\",\n        \"book\": \"伪自由书\",\n        \"title\": \"最艺术的国家\",\n        \"author\": \"鲁迅\",\n        \"type\": \"\",\n        \"source\": \"\",\n        \"date\": \"\",\n        \"chunk\": \"我们中国的最伟大最永久，而且最普遍的“艺术”是男人扮女人。\",\n        \"window\": \"我们中国的最伟大最永久，而且最普遍的“艺术”是男人扮女人。 这艺术的可贵，是在于两面光，或谓之“中庸”---男人看见“扮女人”，女人看见“男人扮”。\",\n        \"method\": \"window_chunk\"\n    },\n    {\n        \"id\": \"伪自由书#最艺术的国家#chunk1\",\n        \"book\": \"伪自由书\",\n        \"title\": \"最艺术的国家\",\n        \"author\": \"鲁迅\",\n        \"type\": \"\",\n        \"source\": \"\",\n        \"date\": \"\",\n        \"chunk\": \"这艺术的可贵，是在于两面光，或谓之“中庸”---男人看见“扮女人”，女人看见“男人扮”。\",\n        \"window\": \"我们中国的最伟大最永久，而且最普遍的“艺术”是男人扮女人。 这艺术的可贵，是在于两面光，或谓之“中庸”---男人看见“扮女人”，女人看见“男人扮”。 表面上是中性，骨子里当然还是男的。\",\n        \"method\": \"window_chunk\"\n    },\n    ...\n]\n```\n\n\n## 创建向量数据库\n文本分块完成，接下来就是文本向量化，导入向量数据库了，这部分你应该比较熟悉了，我直接给出代码。\n\n定义函数 vectorize_file，向量化 json 文件中指定的字段。\n```python\n# 向量化json文件中指定的字段\ndef vectorize_file(input_file_path, encoder, field_name):\n    with open(input_file_path, 'r', encoding='utf-8') as file:\n        data_list = json.load(file)\n        docs = [data[field_name] for data in data_list]\n    # 向量化文档\n    return vectorize_docs(docs, encoder), data_list\n```\n\n为了比较 RAG 使用不同分块方法的效果，我们把三个分块文件全部向量化。\n```python\n# 向量化固定分块的文件\nfixed_vectors, fixed_data_list = vectorize_file(\"luxun_sample_fixed_chunk.json\", bge_m3_ef, \"chunk\")\nfixed_dense_vectors = fixed_vectors['dense']\n\n# 向量化通过标点符号分块的文件\nsemantic_vectors, semantic_data_list = vectorize_file(\"luxun_sample_semantic_chunk.json\", bge_m3_ef, \"chunk\")\nsemantic_dense_vectors = semantic_vectors['dense']\n\n# 向量化通过句子分块的文件\nwindow_vectors, window_data_list = vectorize_file(\"luxun_sample_window_chunk.json\", bge_m3_ef, \"chunk\")\nwindow_dense_vectors = window_vectors['dense']\n```\n\n接下来创建集合。为了能够在同一个集合中区分三种分块方法的搜索结果，我们设置参数 `partition_key_field` 的值为 `method`，它表示采用的分块方法。Milvus 会根据 `method` 字段的值，把数据插入到对应的分区中。打个比方，如果把集合看作一个 excel 文件，partition （分区）就是表格的工作表（Worksheet）。一个 excel 文件包含多张工作表，不同的数据填写在对应的工作表中。相应的，我们把不同的数据插入到对应分区中，搜索时指定分区，就可以提高搜索效率。\n\n```python\n# 创建集合\nfrom pymilvus import MilvusClient, DataType\nimport time\n\n# 删除同名集合\ndef check_collection(collection_name):\n    if milvus_client.has_collection(collection_name):\n        print(f\"集合 {collection_name} 已经存在\")\n        try:\n            milvus_client.drop_collection(collection_name)\n            print(f\"删除集合：{collection_name}\")\n            return True\n        except Exception as e:\n            print(f\"删除集合时出现错误: {e}\")\n            return False\n    return True\n\n# 创建模式\ndef create_schema():\n    schema = milvus_client.create_schema(\n        auto_id=False,\n        enable_dynamic_field=True,\n        partition_key_field=\"method\",\n        num_partitions=16,\n        description=\"\"\n    )\n    schema.add_field(field_name=\"id\", datatype=DataType.VARCHAR, is_primary=True, max_length=100)\n    schema.add_field(field_name=\"book\", datatype=DataType.VARCHAR, max_length=100)\n    schema.add_field(field_name=\"title\", datatype=DataType.VARCHAR, max_length=100)\n    schema.add_field(field_name=\"chunk\", datatype=DataType.VARCHAR, max_length=4000)\n    schema.add_field(field_name=\"window\", datatype=DataType.VARCHAR, max_length=6000)\n    schema.add_field(field_name=\"method\", datatype=DataType.VARCHAR, max_length=30)\n    schema.add_field(field_name=\"dense_vectors\", datatype=DataType.FLOAT_VECTOR, dim=1024)\n    return schema\n\n# 创建集合\ndef create_collection(collection_name, schema, timeout):\n    try:\n        milvus_client.create_collection(\n            collection_name=collection_name,\n            schema=schema,\n            shards_num=2\n        )\n        print(f\"开始创建集合：{collection_name}\")\n    except Exception as e:\n        print(f\"创建集合的过程中出现了错误: {e}\")\n        return False\n\n    # 检查集合是否创建成功\n    start_time = time.time()\n    while True:\n        if milvus_client.has_collection(collection_name):\n            print(f\"集合 {collection_name} 创建成功\")\n            return True\n        elif time.time() - start_time > timeout:\n            print(f\"创建集合 {collection_name} 超时\")\n            return False\n        time.sleep(1)\n\ncollection_name = \"LuXunWorks_sample\"\nuri=\"http://localhost:19530\"\nmilvus_client = MilvusClient(uri=uri)\ntimeout = 10\n\n# 检查并删除集合\nif not check_collection(collection_name):\n    print(f\"无法删除集合 {collection_name}，停止创建。\")\nelse:\n    # 创建集合的模式\n    schema = create_schema()\n    # 创建集合并等待成功\n    create_collection(collection_name, schema, timeout)\n```\n\n把数据插入到向量数据库。\n```python\nfrom tqdm import tqdm\ndef insert_data(\n    collection_name,\n    data_list,\n    dense_vectors,\n    batch_size=1000):         \n    # 接收稠密向量\n    for data, dense_vector in zip(data_list, dense_vectors):\n        data['dense_vectors'] = dense_vector\n\n    # 分批入库\n    print(f\"正在将数据插入集合：{collection_name}\")\n    total_count = len(data_list)\n    with tqdm(total=total_count, desc=\"插入数据\") as progress_bar:\n        # 每次插入 batch_size 条数据\n        for i in range(0, total_count, batch_size):  \n            batch_data = data_list[i:i + batch_size]\n            res = milvus_client.insert(\n                collection_name=collection_name,\n                data=batch_data\n            )\n            progress_bar.update(len(batch_data))\n\ninsert_data(collection_name, fixed_data_list, dense_vectors=fixed_dense_vectors)\ninsert_data(collection_name, semantic_data_list, dense_vectors=semantic_dense_vectors)\ninsert_data(collection_name, window_data_list, dense_vectors=window_dense_vectors)\n```\n\n创建索引。我们使用倒排索引，首先创建索引参数。\n```python\nindex_params = milvus_client.prepare_index_params()\n\nindex_params.add_index(\n    # 指定索引名称\n    index_name=\"IVF_FLAT\",\n    # 指定创建索引的字段\n    field_name=\"dense_vectors\",\n    # 设置索引类型\n    index_type=\"IVF_FLAT\",\n    # 设置度量方式\n    metric_type=\"IP\",\n    # 设置索引聚类中心的数量\n    params={\"nlist\": 128}\n)\n```\n\n接下来创建索引。\n```python\nmilvus_client.create_index(\n    # 指定为创建索引的集合\n    collection_name=collection_name,\n    # 使用前面创建的索引参数创建索引\n    index_params=index_params\n)\n```\n\n验证下索引是否成功创建。查看集合的所有索引。\n```python\nres = milvus_client.list_indexes(\n    collection_name=collection_name\n)\nprint(res)\n```\n\n返回我们创建的索引 `['IVF_FLAT']`。再查看下索引的详细信息。\n```python\nres = milvus_client.describe_index(\n    collection_name=collection_name,\n    index_name=\"IVF_FLAT\"\n)\nprint(res)\n```\n\n返回下面的索引信息，表示索引创建成功：\n```plaintext\n{'nlist': '128', 'index_type': 'IVF_FLAT', 'metric_type': 'IP', 'field_name': 'dense_vectors', 'index_name': 'IVF_FLAT', 'total_rows': 0, 'indexed_rows': 0, 'pending_index_rows': 0, 'state': 'Finished'}\n```\n\n接下来加载集合到内存。\n```python\nprint (f\"正在加载集合：{collection_name}\")\nmilvus_client.load_collection (collection_name=collection_name)\n```\n\n验证下加载状态。\n```python\nprint (milvus_client.get_load_state (collection_name=collection_name))\n```\n\n如果返回 `{'state': <LoadState: Loaded>}`，说明加载完成。接下来，我们定义搜索函数。\n\n先定义搜索参数。\n```python\nsearch_params = {\n    # 度量类型\n    \"metric_type\": \"IP\",\n    # 搜索过程中要查询的聚类单元数量。增加nprobe值可以提高搜索精度，但会降低搜索速度\n    \"params\": {\"nprobe\": 16}\n}\n```\n\n再定义搜索函数。还记得前面我们在创建集合时，设置的 `partition_key_field` 吗？它会根据 `method` 字段的值，把数据插入到相应的分区中。而搜索函数中的 `filter` 参数，就是用来指定在哪个分区中搜索的。\n```python\n# 把查询向量化\ndef vectorize_query(query, encoder):\n    # 验证参数是否符合要求\n    if encoder is None:\n        raise ValueError(\"嵌入模型未初始化。\")\n    if not (isinstance(query, list) and all(isinstance(text, str) for text in query)):\n        raise ValueError(\"query必须为字符串列表。\")\n    return encoder.encode_queries(query)\n\n# 搜索函数\ndef vector_search(\n        query, \n        search_params,\n        limit,\n        output_fields,\n        partition_name\n    ):\n    # 将查询转换为向量\n    query_vectors = [vectorize_query(query, bge_m3_ef)['dense'][0]]\n    # 向量搜索\n    res = milvus_client.search(\n        collection_name=collection_name,\n        # 指定查询向量\n        data=query_vectors,\n        # 指定搜索的字段\n        anns_field=\"dense_vectors\",\n        # 设置搜索参数\n        search_params=search_params,\n        # 设置搜索结果的数量\n        limit=limit,\n        # 设置输出字段\n        output_fields=output_fields,\n        # 在指定分区中搜索\n        filter=f\"method =='{partition_name}'\"\n    )\n    return res\n```\n\n再定义一个打印搜索结果的函数，方便查看。\n```python\n# 打印向量搜索结果\ndef print_vector_results(res):\n    # hit是搜索结果中的每一个匹配的实体\n    res = [hit[\"entity\"] for hit in res[0]]\n    for item in res:\n        print(f\"title: {item['title']}\")\n        print(f\"chunk: {item['chunk']}\")\n        print(f\"method: {item['method']}\")\n        print(\"-\"*50)   \n```\n\n下面我们就来看一看，`fixed_chunk`、`semantic_chunk` 和 `window_chunk` 三位选手在向量搜索上表现如何。首先搜索第一个句子：“世上本没有路，走的人多了，也便成了路。”。\n\n```python\n# 比较不同分块方法产生的搜索结果\nquery1 = [\"世上本没有路，走的人多了，也便成了路。\"]\nlimit = 1\noutput_fields = [\"title\", \"chunk\", \"window\", \"method\"]\n\n# 定义分块方法列表\nchunk_methods = [\"fixed_chunk\", \"semantic_chunk\", \"window_chunk\"]\n\n# 定义一个函数来执行搜索并打印结果\ndef compare_chunk_methods(query, search_params, limit, output_fields, methods):\n    for method in methods:\n        res = vector_search(query, search_params, limit, output_fields, method)\n        print(f\"{method} 的搜索结果是：\\n\")\n        print_vector_results(res)\n        print(\"*\" * 50)\n\n# 调用函数进行比较\ncompare_chunk_methods(query1, search_params, limit, output_fields, chunk_methods)\n```\n\n`fixed_chunk` 选手的确搜索到了原文，但是并不完整。这也是 `fixed_chunk` 分块的典型问题。\n\n搜索结果如下：\n\n>的人多了，也便成了路。一九二一年一月。 \n\n`semantic_chunk` 选手的表现让人失望，它并没有搜索到原文。它的搜索结果是：\n\n>跨过了灭亡的人们向前进。什么是路？就是从没路的地方践踏出来的，从只有荆棘的地方开辟出来的。以前早有路了，以后也该永远有路。人类总不会寂寞，因为生命是进步的，是乐天的。昨天，我对我的朋友 L 说，“一个人死了，在死者自身和他的眷属是悲惨的事，\n\n但是它给我们带来了意外收获，搜索结果的意思和原文有些类似。这也是向量数据库语义搜索功能的体现。\n\n原文其实在这个块中：\n\n> \"我的愿望茫远罢了。我在朦胧中，眼前展开一片海边碧绿的沙地来，上面深蓝的天空中挂着一轮金黄的圆月。我想：希望本是无所谓有，无所谓无的。这正如地上的路；其实地上本没有路，走的人多了，也便成了路。一九二一年一月。\"\n\n`semantic_chunk` 选手没有搜索到它，可能是因为这个块的前半部分和查询句子的语义相差较远。这也反应了分块对搜索结果的影响。\n\n最后出场的 `window_chunk` 选手，给出了标准答案：\n\n> 这正如地上的路；其实地上本没有路，走的人多了，也便成了路。\n\n恭喜 `window_chunk` 选手完美找到了原文。因为它基于句子分割，能够更好地保存句子的语义。\n\n我们再来看看第二个句子，三位选手的表现如何。搜索句子：“我家墙外有两株树，一株是枣树，还有一株也是枣树。”\n\n`fixed_chunk` 选手给出的句子仍然不完整，但是包含了完整的原文：\n\n> 在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。这上面的夜的天空，奇怪而高，我生平没有见过这样的奇怪而高的天空。他仿佛要离开人间而去，使人们仰面不再看见。然而现在却非常之蓝，闪闪地䀹着几十个星星的眼，冷眼。他的口角上现出微笑，似乎自以为大有深意，而将繁霜洒在我的园里的野花草上。我不知\n\n`semantic_chunk` 选手这次正常发挥，也找到了原文：\n\n> 在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。这上面的夜的天空，奇怪而高，我生平没有见过这样的奇怪而高的天空。他仿佛要离开人间而去，使人们仰面不再看见。然而现在却非常之蓝，闪闪地䀹着几十个星星的眼，冷眼。他的口角上现出微笑，\n\n`window_chunk` 选手依旧给出了完美答案：\n\n> 在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。\n\n虽然三位选手都找到了原文，但是 `window_chunk` 选手返回的原文不但完整，而且没有包含无关内容，减少了干扰信息。\n\n再来看看最后一个句子：\n\n> “猛兽总是独行，牛羊才成群结对。”\n\n`fixed_chunk` 选手找到了类似的句子，但是包含了较多的无关内容：\n\n> 兽是单独的，牛羊则结队；野牛的大队，就会排角成城以御强敌了，但拉开一匹，定只能牟牟地叫。人民与牛马同流，——此就中国而言，夷人别有分类法云，——治之之道，自然应该禁止集合：这方法是对的。其次要防说话。人能说话，已经是祸胎了，而况有时还要做文章。所以苍颉造字，夜有鬼哭。鬼且反对，而况于官？猴子不会说话\n\n`semantic_chunk` 和 `fixed_chunk` 表现类似：\n\n> 牛羊则结队；野牛的大队，就会排角成城以御强敌了，但拉开一匹，定只能牟牟地叫。人民与牛马同流，——此就中国而言，夷人别有分类法云，——治之之道，自然应该禁止集合：这方法是对的。其次要防说话。人能说话，已经是祸胎了，而况有时还要做文章。所以苍颉造字，夜有鬼哭。\n\n我们最后看看 `window_chunk` 选手的表现：\n\n> 猛兽是单独的，牛羊则结队；野牛的大队，就会排角成城以御强敌了，但拉开一匹，定只能牟牟地叫。\n\n别忘了 `window_chunk` 选手除了搜索到的原始句子，还能提供“窗口句子”作为上下文：\n```python\n# 查看`window_chunk`方法的窗口句子\nmethod = \"window_chunk\"\nres_window_chunk = vector_search(query3, search_params, limit, output_fields, method)\nres_window_chunk = [hit[\"entity\"] for hit in res_window_chunk[0]]\nfor item in res_window_chunk:\n    print(f\"window: {item['window']}\")\n```\n\n窗口句子如下：\n```plaintext\nwindow: 然亦可见至道嘉猷，人同此心，心同此理，固无华夷之限也。 猛兽是单独的，牛羊则结队；野牛的大队，就会排角成城以御强敌了，但拉开一匹，定只能牟牟地叫。 人民与牛马同流，——此就中国而言，夷人别有分类法云，——治之之道，自然应该禁止集合：这方法是对的。\n```\n\n在 RAG 应用中，把上下文句子一起传递给大模型，能让大模型更好地理解句子的语义，作出更好的回答。\n\n## 调用大模型的 API\n创建向量数据库这部分想必你已经轻车熟路了，下面我们来完成 RAG 应用的最后一个部分：生成。我们要把搜索到的句子传递给大模型，让它根据提示词重新组装成回答。\n\n首先，我们要创建一个大模型的 api key，用来调用大模型。我使用的是 [deepseek](https://platform.deepseek.com/api_keys)。为了保护 api key 的安全，把 api key 设置为环境变量“DEEPSEEK_API_KEY”。请把 `<you_api_key>` 替换成你自己的 api key。\n\n```python\nimport os\nos.environ['DEEPSEEK_API_KEY'] = <you_api_key>\n```\n\n然后，再从环境变量中读取 api key。\n```python\ndeepseek_api_key = os.getenv(\"DEEPSEEK_API_KEY\")\n```\n\ndeepseek 使用与 OpenAI 兼容的 API 格式，我们可以使用 OpenAI SDK 来访问 DeepSeek API。\n```shell\n# 安装 openai 库\npip install openai\n```\n\n接下来创建 openai 客户端实例。\n```python\n# 导入openai库\nfrom openai import OpenAI\n\n# 导入os库\nimport os\n\n# 创建openai客户端实例\nOpenAI_client = OpenAI(api_key=deepseek_api_key, base_url=\"https://api.deepseek.com\")\n```\n\n根据 [deepseek api 文档](https://api-docs.deepseek.com/zh-cn/)的说明，定义生成响应的函数 `generate_response`。`model` 是我们使用的大模型，这里是 `deepseek-chat`。`temperature` 决定大模型回答的随机性，数值在0-2之间，数值越高，生成的文本越随机；值越低，生成的文本越确定。\n```python\n# 定义生成响应的函数\ndef generate_response(\n        system_prompt, \n        user_prompt, \n        model, \n        temperature\n    ):\n    # 大模型的响应\n    response = OpenAI_client.chat.completions.create(\n        model=model,\n        messages=[\n            # 设置系统信息，通常用于设置模型的行为、角色或上下文。\n            {\"role\": \"system\", \"content\": system_prompt},\n            # 设置用户消息，用户消息是用户发送给模型的消息。\n            {\"role\": \"user\", \"content\": user_prompt},\n        ],\n        # 设置温度\n        temperature=temperature,  \n        stream=True\n    )\n    # 遍历响应中的每个块\n    for chunk in response:\n        # 检查块中是否包含选择项\n        if chunk.choices:\n            # 打印选择项中的第一个选项的增量内容，并确保立即刷新输出\n            print(chunk.choices[0].delta.content, end=\"\", flush=True)\n```\n\n响应函数接收的参数中，`system_prompt` 是系统提示词，主要用于设置模型的行为、角色或上下文。你可以理解为这是系统给大模型的提示词，而且始终有效。我们可以使用下面的提示词规范大模型的响应：\n```python\nsystem_prompt = \"你是鲁迅作品研究者，熟悉鲁迅的各种作品。\"\n```\n\n`user_prompt` 是用户提示词，是用户发给大模型的。大模型会在系统提示词和用户提示词的共同作用下，生成响应。用户提示词由查询句子 `query` 和向量数据库搜索到的句子组成。对于 `fixed_chunk` 和 `semantic_chunk`，我们需要获取 `chunk` 字段的值。对于 `window_chunk`，我们需要获取 `window` 字段的值。定义下面的函数可以帮助我们方便获取想要的值。\n```python\ndef get_ref_info (query, search_params, limit, output_fields, method):\n    res = vector_search (query, search_params, limit, output_fields, method)\n    for hit in res[0]:\n        ref_info = {\n            \"ref\": hit[\"entity\"][\"window\"] if method == \"window_chunk\" else hit[\"entity\"][\"chunk\"],\n            \"title\": hit[\"entity\"][\"title\"]\n        }\n    return ref_info\n```\n\n最后，针对不同的分块方法，获取对应的响应。\n```python\nfor method in chunk_methods:\n    print(f\"分块方法: {method}\")\n    # 获取参考信息\n    ref_info = get_ref_info(query, search_params, limit, output_fields, method)\n    # 生成用户提示词\n    user_prompt = (\n        f\"请你根据提供的参考信息，查找是否有与问题语义相似的内容。参考信息：{ref_info}。问题：{query}。\\n\"\n        f\"如果找到了相似的内容，请回复“鲁迅的确说过类似的话，原文是[原文内容]，这句话来自[文章标题]”。\\n\"\n        f\"[原文内容]是参考信息中ref字段的值，[文章标题]是参考信息中title字段的值。如果引用它们，请引用完整的内容。\\n\"\n        f\"如果参考信息没有提供和问题相关的内容，请回答“据我所知，鲁迅并没有说过类似的话。”\"\n)\n    # 生成响应\n    generate_response(system_prompt, user_prompt, model, temperature)\n    print(\"\\n\" + \"*\" * 50 + \"\\n\")\n```\n\n好啦，一切准备就绪，让我们看看使用不同分块方法的 RAG，究竟有什么区别。先看第一句话，“世上本没有路，走的人多了，也便成了路。”，搜索结果：\n\n```plaintext\n分块方法: fixed_chunk\n鲁迅的确说过类似的话，原文是“的人多了，也便成了路。 一九二一年一月。”，这句话来自《故乡》。\n**************************************************\n\n分块方法: semantic_chunk\n鲁迅的确说过类似的话，原文是“跨过了灭亡的人们向前进。什么是路？就是从没路的地方践踏出来的，从只有荆棘的地方开辟出来的。以前早有路了，以后也该永远有路。人类总不会寂寞，因为生命是进步的，是乐天的。昨天，我对我的朋友L说，‘一个人死了，在死者自身和他的眷属是悲惨的事，”，这句话来自《六十六生命的路》。\n**************************************************\n\n分块方法: window_chunk\n鲁迅的确说过类似的话，原文是“我想：希望本是无所谓有，无所谓无的。 这正如地上的路；其实地上本没有路，走的人多了，也便成了路。 一九二一年一月。”，这句话来自《故乡》。\n**************************************************\n```\n\n`fixed_chunk` 选手虽然给出了原文，但是遗憾的是不够完整。`semantic_chunk` 选手没有搜索到原文，但是给出的句子语义也和原文类似，算是意外收获。而 `window_chunk` 选手则给出了标准答案。\n\n再来看看第二句，“我家墙外有两株树，一株是枣树，还有一株也是枣树。”搜索结果：\n\n```plaintext\n分块方法: fixed_chunk\n鲁迅的确说过类似的话，原文是在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。这上面的夜的天空，奇怪而高，我生平没有见过这样的奇怪而高的天空。他仿佛要离开人间而去，使人们仰面不再看见。然而现在却非常之蓝，闪闪地䀹着几十个星星的眼，冷眼。他的口角上现出微笑，似乎自以为大有深意，而将繁霜洒在我的园里的野花草上。我不知，这句话来自秋夜。\n**************************************************\n\n分块方法: semantic_chunk\n鲁迅的确说过类似的话，原文是“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。这上面的夜的天空，奇怪而高，我生平没有见过这样的奇怪而高的天空。他仿佛要离开人间而去，使人们仰面不再看见。然而现在却非常之蓝，闪闪地䀹着几十个星星的眼，冷眼。他的口角上现出微笑，”，这句话来自《秋夜》。\n**************************************************\n\n分块方法: window_chunk\n鲁迅的确说过类似的话，原文是“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。 这上面的夜的天空，奇怪而高，我生平没有见过这样的奇怪而高的天空。”，这句话来自《秋夜》。\n**************************************************\n```\n\n三位选手表现差不多，`window_chunk` 选手给出的结果更精准。\n\n最后来看看第三句，“猛兽总是独行，牛羊才成群结对。”搜索结果：\n\n```plaintext\n分块方法: fixed_chunk\n鲁迅的确说过类似的话，原文是“兽是单独的，牛羊则结队；野牛的大队，就会排角成城以御强敌了，但拉开一匹，定只能牟牟地叫。人民与牛马同流，——此就中国而言，夷人别有分类法云，——治之之道，自然应该禁止集合：这方法是对的。其次要防说话。人能说话，已经是祸胎了，而况有时还要做文章。所以苍颉造字，夜有鬼哭。鬼且反对，而况于官？猴子不会说话”，这句话来自《春末闲谈》。\n**************************************************\n\n分块方法: semantic_chunk\n鲁迅的确说过类似的话，原文是“牛羊则结队；野牛的大队，就会排角成城以御强敌了，但拉开一匹，定只能牟牟地叫。人民与牛马同流，——此就中国而言，夷人别有分类法云，——治之之道，自然应该禁止集合：这方法是对的。其次要防说话。人能说话，已经是祸胎了，而况有时还要做文章。所以苍颉造字，夜有鬼哭。”，这句话来自《春末闲谈》。\n**************************************************\n\n分块方法: window_chunk\n鲁迅的确说过类似的话，原文是“猛兽是单独的，牛羊则结队；野牛的大队，就会排角成城以御强敌了，但拉开一匹，定只能牟牟地叫。”，这句话来自《春末闲谈》。\n**************************************************\n```\n\n和上一句的搜索结果相似，三位选手都找到了正确的句子，`window_chunk` 选手的答案最标准。请为 `window_chunk` 选手的精彩表现鼓掌。\n\n## 更多探索\n其实，RAG 的响应和很多因素相关，你可以多多尝试，看看结果有什么不同。比如，修改 `vector_search` 函数的 `limit` 参数，让向量数据库多返回几个句子，增加命中概率。或者增加 `generate_response` 函数的 `temperature` 参数，看看 RAG 的响应如何变化。还有提示词，它直接影响大模型如何回答。\n\n另外，你还可以基于本应用，开发其他功能，比如鲁迅作品智能问答功能，解答关于鲁迅作品的问题。或者鲁迅作品推荐功能，输入你想要阅读的作品类型，让 RAG 为你做推荐。玩法多多，祝你玩得开心。\n\n## 藏宝图\n老规矩，推荐一些资料供你参考。\n[ChunkViz](https://chunkviz.up.railway.app/) 是一个在线网站，提供分块可视化功能。\n\n想了解 RAG 更多有趣应用，可以看看这个视频：[当我开发出史料检索RAG应用，正史怪又该如何应对？](https://www.bilibili.com/video/BV1da4y1k78p/?spm_id_from=333.337.search-card.all.click&vd_source=ad92e3138da83a643ab3f5883c7664c7)。想了解更多技术细节，看这里： [揭秘「 B 站最火的 RAG 应用」是如何炼成的](https://zilliz.com.cn/blog/milvus-rag-bilibili)。\n\n想了解更多分块技术，可以阅读[检索增强生成（RAG）的分块策略指南](https://zilliz.com.cn/blog/guide-to-chunking-sreategies-for-rag)和[从固定大小到NLP分块 - 文本分块技术的深入研究](https://safjan.com/from-fixed-size-to-nlp-chunking-a-deep-dive-into-text-chunking-techniques/)两篇文章。\n\n## 注释\n[^1]: 鲁迅作品集数据基于 [luxun_dataset](https://github.com/sun510001/luxun_dataset) ，增加了一些字段。`luxun_sample.json` 为鲁迅部分作品，方便试用。`luxun.json` 为完整的鲁迅作品集。\n[^2]: LlamaIndex 是一个用于构建带有上下文增强功能的生成式 AI 应用的框架，支持大型语言模型（LLMs）。","categories":["向量数据库","原理探秘"]},{"title":"孙悟空 + 红楼梦 - 西游记 = ？向量嵌入之稠密向量","url":"/2024/10/11/孙悟空-红楼梦-西游记-？向量嵌入之稠密向量/","content":"\n一起来开个脑洞，如果孙悟空穿越到红楼梦的世界，他会成为谁？贾宝玉，林黛玉，还是薛宝钗？这看似一道文学题，但是我们不妨用数学方法来求解：`孙悟空 + 红楼梦 - 西游记 = ？`\n\n文字也能做运算？当然不行，但是把文字转换成数字之后，就可以用来计算了。而这个过程，叫做 “向量嵌入”。为什么要做向量嵌入？因为具有语义意义的数据，比如文本或者图像，人可以分辨相关程度，但是无法量化，更不能计算。比如，对于一组词“孙悟空、猪八戒、沙僧、西瓜、苹果、香蕉“，我会把“孙悟空、猪八戒、沙僧”分成一组，“西瓜、苹果、香蕉”分成另一组。但是，如果进一步提问，“孙悟空”是和“猪八戒”更相关，还是和“沙僧”更相关呢？这很难回答。\n\n而把这些信息转换成向量后，相关程度就可以通过它们在向量空间中的距离量化。甚至于，我们可以做 `孙悟空 + 红楼梦 - 西游记 = ？` 这样的脑洞数学题。\n\n>本文首发于 Zilliz 公众号。文中代码的 Notebook 在[这里]( https://pan.baidu.com/s/1VtPt-6Y_hhxKn9uB4AMNFg?pwd=7zv9 )下载。\n\n## 文字是怎么变成向量的\n怎么把文字变成向量呢？首先出现的是词向量，其中的代表是 word2vec 模型。它先准备一张词汇表，给每个词随机赋予一个向量，然后利用大量语料，通过 CBOW（Continuous Bag-of-Words）和 Skip-Gram 两种方法训练模型，不断优化字词的向量。\n\nCBOW 使用上下文（周围的词）预测目标词[^1]，而 Skip-Gram 则相反，通过目标词预测它的上下文。举个例子，对于“我爱吃冰淇淋”这个句子，CBOW方法已知上下文“我爱“和”冰淇淋”，计算出中间词的概率，比如，“吃”的概率是90%，“喝”的概率是7%，“玩”的概率是3%。然后再使用损失函数预测概率与实际概率的差异，最后通过反向传播算法，调整词向量模型的参数，使得损失函数最小化。训练词向量模型的最终目的，是捕捉词汇之间的语义关系，使得相关的词在向量空间中距离更近。\n\n打个比方，最初的词向量模型就像一个刚出生的孩子，对字词的理解是模糊的。父母在各种场景下和孩子说话，时不时考一考孩子，相当于用语料库训练模型。只不过训练模型的过程是不断迭代神经网络的参数，而教孩子说话，则是改变大脑皮层中神经元突触的连接。\n\n比如，父母会在吃饭前跟孩子说：\n“肚子饿了就要...”\n“要吃饭。”\n\n如果答错了，父母会纠正孩子：\n“吃饭之前要...”\n“要喝汤。”\n\"不对，吃饭之前要洗手。\"\n\n这就是在调整模型的参数。\n\n好了，纸上谈兵结束，咱们用代码实际操练一番吧。\n\n版本说明：\nMilvus 版本：>=2.5.0\npymilvus 版本：>=2.5.0\n\n安装依赖：\n```shell\npip install gensim scikit-learn transformers matplotlib\n```\n\n从 gensim.models 模块中导入 KeyedVectors 类，它用于存储和操作词向量。\n```python\nfrom gensim.models import KeyedVectors\n```\n\n在[这里](https://github.com/Embedding/Chinese-Word-Vectors/blob/master/README_zh.md)下载中文词向量模型 `Literature 文学作品`，并且加载该模型。\n\n```python\n# 加载中文词向量模型\nword_vectors = KeyedVectors.load_word2vec_format('sgns.literature.word', binary=False)\n```\n\n词向量模型其实就像一本字典。在字典里，每个字对应的是一条解释，在词向量模型中，每个词对应的是一个向量。\n\n我们使用的词向量模型是300维的，数量太多，可以只显示前4个维度的数值：\n```python\nprint(f\"'孙悟空'的向量的前四个维度：{word_vectors['孙悟空'].tolist()[:4]}\")\n```\n\n输出结果为：\n```plaintext\n'孙悟空'的向量的前四个维度：[-0.09262000024318695, -0.034056998789310455, -0.16306699812412262, -0.05771299824118614]\n```\n\n## 语义更近，距离更近\n前面我们提出了疑问，“孙悟空”是和“猪八戒”更相关，还是和“沙僧”更相关呢？在 [如何假装文艺青年，怎么把大白话“变成”古诗词？](http://jiangjunqiao.top/2024/09/16/如何假装文艺青年，怎么把大白话“变成”古诗词？/) 这篇文章中，我们使用内积 `IP` 计算两个向量的距离，这里我们使用余弦相似度来计算。\n\n```python\nprint(f\"'孙悟空'和'猪八戒'向量的余弦相似度是：{word_vectors.similarity('孙悟空', '猪八戒'):.2f}\")\n\nprint(f\"'孙悟空'和'沙僧'向量的余弦相似度是：{word_vectors.similarity('孙悟空', '沙僧'):.2f}\")\n```\n\n返回：\n```plaintext\n'孙悟空'和'猪八戒'向量的余弦相似度是：0.60\n'孙悟空'和'沙僧'向量的余弦相似度是：0.59\n```\n\n看来，孙悟空还是和猪八戒更相关。但是我们还不满足，我们还想知道，和孙悟空最相关的是谁。\n\n```python\n# 查找与“孙悟空”最相关的4个词\nsimilar_words = word_vectors.most_similar(\"孙悟空\", topn=4)\nprint(f\"与'孙悟空'最相关的4个词分别是：\")\nfor word, similarity in similar_words:\n\tprint(f\"{word}， 余弦相似度为：{similarity:.2f}\")\n```\n\n返回：\n```plaintext\n与'孙悟空'最相关的4个词分别是：\n悟空， 余弦相似度为：0.66\n唐僧， 余弦相似度为：0.61\n美猴王， 余弦相似度为：0.61\n猪八戒， 余弦相似度为：0.60\n```\n\n“孙悟空”和“悟空”、“美猴王”相关，这容易理解。为什么它还和“唐僧”、“猪八戒”相关呢？前面提到的词向量模型的训练原理解释，就是因为在训练文本中，“唐僧”、“猪八戒”经常出现在“孙悟空”这个词的上下文中。这不难理解——在《西游记》中，孙悟空经常救唐僧，还喜欢戏耍八戒。\n\n前面提到，训练词向量模型是为了让语义相关的词，在向量空间中距离更近。那么，我们可以测试一下，给出四组语义相近的词，考一考词向量模型，看它能否识别出来。\n\n第一组：西游记，三国演义，水浒传，红楼梦\n第二组：西瓜，苹果，香蕉，梨\n第三组：长江，黄河\n\n首先，获取这四组词的词向量：\n```python\n# 导入用于数值计算的库\nimport numpy as np\n\n# 定义要可视化的单词列表\nwords = [\"西游记\", \"三国演义\", \"水浒传\", \"红楼梦\", \n        \"西瓜\", \"苹果\", \"香蕉\", \"梨\", \n        \"长江\", \"黄河\"]\n\n# 使用列表推导式获取每个单词的向量\nvectors = np.array([word_vectors[word] for word in words])\n```\n\n然后，使用 PCA （Principal Component Analysis，组成分分析）把200维的向量降到2维，一个维度作为 x 坐标，另一个维度作为 y 坐标，这样就把高维向量投影到平面了，方便我们在二维图形上显示它们。换句话说，PCA 相当于《三体》中的二向箔，对高维向量实施了降维打击。\n\n```python\n# 导入用于降维的PCA类\nfrom sklearn.decomposition import PCA\n\n# 创建PCA对象，设置降至2维\npca = PCA(n_components=2)\n\n# 对词向量实施PCA降维\nvectors_pca = pca.fit_transform(vectors)\n```\n\n最后，在二维图形上显示降维后的向量。\n```python\n# 导入用于绘图的库\nimport matplotlib.pyplot as plt\n# 创建一个5x5英寸的图\nfig, axes = plt.subplots(1, 1, figsize=(7, 7))\n\n# 设置中文字体\nplt.rcParams['font.sans-serif'] = ['Heiti TC']\n# 确保负号能够正确显示\nplt.rcParams['axes.unicode_minus'] = False  \n\n# 使用PCA降维后的前两个维度作为x和y坐标绘制散点图\naxes.scatter(vectors_pca[:, 0], vectors_pca[:, 1])\n\n# 为每个点添加文本标注\nfor i, word in enumerate(words):\n    # 添加注释，设置文本内容、位置、样式等\n    # 要显示的文本（单词）\n    axes.annotate(word,\n                  # 点的坐标\n                  (vectors_pca[i, 0], vectors_pca[i, 1]),  \n                  # 文本相对于点的偏移量\n                  xytext=(2, 2),  \n                  # 指定偏移量的单位\n                  textcoords='offset points',  \n                  # 字体大小\n                  fontsize=10,  \n                  # 字体粗细\n                  fontweight='bold')  \n\n# 设置图表标题和字体大小\naxes.set_title('词向量', fontsize=14)\n\n# 自动调整子图参数，使之填充整个图像区域\nplt.tight_layout()\n\n# 在屏幕上显示图表\nplt.show()\n```\n\n从图中可以看出，同一组词的确在图中的距离更近。\n\n![600](https://picgo233.oss-cn-hangzhou.aliyuncs.com/img/202409161007773.png)\n\n既然可以把高维向量投影到二维，那么是不是也能投影到三维呢？当然可以，那样更酷。你可以在 [TensorFlow Embedding Projector](https://projector.tensorflow.org/) 上尝试下，输入单词，搜索与它最近的几个词，看看它们在三维空间上的位置关系。\n\n比如，输入 `apple`，最接近的5个词分别是 `OS`、`macintosh`、`amiga`、`ibm` 和 `microsoft`。\n\n![600](https://picgo233.oss-cn-hangzhou.aliyuncs.com/img/202409161023693.png)\n\n## 如果孙悟空穿越到红楼梦\n回到我们开篇的问题，把文本向量化后，就可以做运算了。如果孙悟空穿越到红楼梦，我们用下面的数学公式表示：\n`孙悟空 + 红楼梦 - 西游记`\n\n```python\nresult = word_vectors.most_similar(positive=[\"孙悟空\", \"红楼梦\"], negative=[\"西游记\"], topn=4)\n\nprint(f\"孙悟空 + 红楼梦 - 西游记 = {result}\")\n```\n\n答案为：\n```plaintext\n孙悟空 + 红楼梦 - 西游记 = [('唐僧', 0.4163001477718353), ('贾宝玉', 0.41606390476226807), ('妙玉', 0.39432790875434875), ('沙和尚', 0.3922004997730255)]\n```\n\n你是不是有点惊讶，因为答案中的“唐僧”和“沙和尚”根本就不是《红楼梦》中的人物。这是因为虽然词向量可以反映字词之间的语义相关性，但是它终究是在做数学题，不能像人类一样理解“孙悟空 + 红楼梦 - 西游记”背后的含义。答案中出现“唐僧”和“沙和尚”是因为它们和“孙悟空”更相关，而出现“贾宝玉”和“妙玉”则是因为它们和“红楼梦”更相关。\n\n不过，这样的测试还蛮有趣的，你也可以多尝试一下，有的结果还蛮符合直觉的。\n\n```python\nresult = word_vectors.most_similar(positive=[\"牛奶\", \"发酵\"], topn=1)\nprint(f\"牛奶 + 发酵 = {result[0][0]}\")\n\nresult = word_vectors.most_similar(positive=[\"男人\", \"泰国\"], topn=1)\nprint(f\"男人 + 泰国 = {result[0][0]}\")\n```\n\n计算的结果如下：\n```plaintext\n牛奶 + 发酵 = 变酸\n男人 + 泰国 = 女人\n```\n\n## 待优化！\n尝试把上面的计算题降维，显示在图像上，看看是否满足两个向量相加，等于第三个向量\n\n\n## 一词多义怎么办\n前面说过，词向量模型就像一本字典，每个词对应一个向量，而且是唯一一个向量。但是，在语言中一词多义的现象是非常常见的，比如对于 “苹果” 这个词，既可以指一种水果，也可以指一家电子产品公司。词向量模型在训练 “苹果”这个词的向量时，这两种语义都会考虑到，所以它在向量空间中将位于“水果”和 “电子产品公司”之间。这就好像你3月20号过生日，你同事3月30号过生日，你的领导为了给你们两个人一起过庆祝生日，选择了3月25号——不是任何一个人的生日。\n\n为了解决一词多义的问题，BERT（Bidirectional Encoder Representations from Transformers）模型诞生了。它是一种基于深度神经网络的预训练语言模型，使用 Transformer 架构，通过自注意力机制同时考虑一个 token 的前后上下文，并且根据上下文环境更新该 token 的向量。\n\n比如，“苹果”这个目标词的初始向量是从词库中获取的，向量的值是固定的。当注意力模型处理“苹果“这个词时，如果发现上下文中有“手机”一词，会给它分配更多权重，“苹果”的向量会更新，靠近“手机”的方向。如果上下文中有“水果”一词，则会靠近“水果”的方向。\n\n注意力模型分配权重是有策略的。它只会给上下文中与目标词关系紧密的词分配更多权重。所以，BERT 能够理解目标词与上下文之间的语义关系，根据上下文调整目标词的向量。\n\nBERT 的预训练分成两种训练方式。第一种训练方式叫做“掩码语言模型（Masked Language Model，MLM）”，和 word2vec 相似，它会随机选择句子中的一些词遮住，根据上下文信息预测这个词，再根据预测结果与真实结果的差异调整参数。第二种训练方式叫做“下一句预测（Next Sentence Prediction，NSP）”，每次输入两个句子，判断第二个句子是否是第一个句子的下一句，然后同样根据结果差异调整参数。\n\n说了这么多，BERT 模型的效果究竟怎么样？让我们动手试试吧。首先导入 BERT 模型，定义一个获取句子中指定单词的向量的函数。\n\n```python\n# 从transformers库中导入BertTokenizer类和BertModel类\nfrom transformers import BertTokenizer, BertModel\n\n# 加载分词器 BertTokenizer\nbert_tokenizer = BertTokenizer.from_pretrained('bert-base-chinese')\n\n# 加载嵌入模型 BertModel\nbert_model = BertModel.from_pretrained('bert-base-chinese')\n\n# 使用BERT获取句子中指定单词的向量\ndef get_bert_emb(sentence, word):\n    # 使用 bert_tokenizer 对句子编码\n    input = bert_tokenizer(sentence, return_tensors='pt')\n    # 将编码传递给 BERT 模型，计算所有层的输出\n    output = bert_model(**input)\n    # 获取 BERT 模型最后一层的隐藏状态，它包含了每个单词的嵌入信息\n    last_hidden_states = output.last_hidden_state\n    # 将输入的句子拆分成单词，并生成一个列表\n    word_tokens = bert_tokenizer.tokenize(sentence)\n    # 获取目标单词在列表中的索引位置\n    word_index = word_tokens.index(word)\n    # 从最后一层隐藏状态中提取目标单词的嵌入表示\n    word_emb = last_hidden_states[0, word_index + 1, :]\n    # 返回目标单词的嵌入表示\n    return word_emb\n```\n\n然后通过 BERT 和词向量模型分别获取两个句子中指定单词的向量。\n\n```python\nsentence1 = \"我今天很开心。\"\nsentence2 = \"我打开了房门。\"\nword = \"开\"\n\n# 使用 BERT 模型获取句子中指定单词的向量\nbert_emb1 = get_bert_emb(sentence1, word).detach().numpy()\n\nbert_emb2 = get_bert_emb(sentence2, word).detach().numpy()\n\n# 使用词向量模型获取指定单词的向量\nword_emb = word_vectors[word]\n```\n\n最后，查看这三个向量的区别。\n\n```python\nprint(f\"在句子 '{sentence1}' 中，'{word}'的向量的前四个维度：{bert_emb1[: 4]}\")\n\nprint(f\"在句子 '{sentence2}' 中，'{word}'的向量的前四个维度：{bert_emb2[: 4]}\")\n\nprint(f\"在词向量模型中， '{word}' 的向量的前四个维度：{word_emb[: 4]}\")\n```\n\n结果为：\n```plaintext\n在句子 '我今天很开心。' 中，'开'的向量的前四个维度：[1.4325644  0.05137304 1.6045816  0.01002912]\n\n在句子 '我打开了房门。' 中，'开'的向量的前四个维度：[ 0.9039772  -0.5877741   0.6639165   0.45880783]\n\n在词向量模型中， '开' 的向量的前四个维度：[ 0.260962  0.040874  0.434256 -0.305888]\n```\n\nBERT 模型果然能够根据上下文调整单词的向量。不妨再比较下余弦相似度：\n\n```python\n# 导入用于计算余弦相似度的函数\nfrom sklearn.metrics.pairwise import cosine_similarity\n\n# 计算两个BERT嵌入向量的余弦相似度\nbert_similarity = cosine_similarity([bert_emb1], [bert_emb2])[0][0]\nprint(f\"在 '{sentence1}' 和 '{sentence2}' 这两个句子中，两个 '{word}' 的余弦相似度是: {bert_similarity:.2f}\")\n\n# 计算词向量模型的两个向量之间的余弦相似度\nword_similarity = cosine_similarity([word_emb], [word_emb])[0][0]\nprint(f\"在词向量中， '{word}' 和 '{word}' 的余弦相似度是: {word_similarity:.2f}\")\n```\n\n观察结果发现，不同句子中的“开”语义果然不同：\n```plaintext\n在 '我今天很开心。' 和 '我打开了房门。' 这两个句子中，两个 '开' 的余弦相似度是: 0.69\n\n在词向量中， '开' 和 '开' 的余弦相似度是: 1.00\n```\n\n## 怎么获得句子的向量\n我们虽然可以通过 BERT 模型获取单词的向量，但是怎么获得句子的向量呢？最简单的方法就是让 BERT 输出句子中每个单词的向量，然后计算向量的平均值。但是，这种不分重点一刀切的效果肯定是不好的，就好像我和千万富豪站在一起，计算我们的平均资产，然后得出结论，这两个人都是千万富翁，这显然不能反映真实情况。更关键的是，使用这种方法，并不能反映句子中词的顺序，而词序对句子语义的影响是非常大的。\n``\n所以，想要反映句子的语义，必须使用专门的句子嵌入模型。它能够直接生成句子级别的嵌入表示，更好地捕捉句子中的上下文信息，从而生成更准确的句子向量。\n\n句子嵌入模型是怎么训练的？一种常见方法是使用句子对。每次输入两个句子，分别生成它们的嵌入向量，计算相似度，然后与句子对自带的相似度做比较，通过差异调整嵌入模型的参数。\n\nBGE_M3 模型就是这样一个嵌入模型，而且支持中文。\n\n真的这么好用？是骡子是马，拉出来遛遛，我们比较一下这两种生成句子嵌入的方法。\n\n首先，定义一个使用 BERT 模型获取句子向量的函数。\n```python\n# 导入 PyTorch 库\nimport torch\n\n# 使用 BERT 模型获取句子的向量\ndef get_bert_sentence_emb(sentence):\n    # 使用 bert_tokenizer 对句子进行编码，得到 PyTorch 张量格式的输入\n    input = bert_tokenizer(sentence, return_tensors='pt')\n    # print(f\"input: {input}\")\n    # 将编码后的输入传递给 BERT 模型，计算所有层的输出\n    output = bert_model(**input)\n    # print(f\"output: {output}\")\n    # 获取 BERT 模型最后一层的隐藏状态，它包含了每个单词的嵌入信息\n    last_hidden_states = output.last_hidden_state\n    # 将所有词的向量求平均值，得到句子的表示\n    sentence_emb = torch.mean(last_hidden_states, dim=1).flatten().tolist()\n    # 返回句子的嵌入表示\n    return sentence_emb\n```\n\n然后，定义一个用 bge_m3模型获取句子向量的函数。\n```python\n# 导入 bge_m3 模型\nfrom pymilvus.model.hybrid import BGEM3EmbeddingFunction\n\n# 使用 bge_m3 模型获取句子的向量\ndef get_bgem3_sentence_emb(sentence, model_name='BAAI/bge-m3'):\n    bge_m3_ef = BGEM3EmbeddingFunction(\n        model_name=model_name,\n        device='cpu',\n        use_fp16=False\n    )\n    vectors = bge_m3_ef.encode_documents([sentence])\n    return vectors['dense'][0].tolist()\n```\n\n接下来，先计算下 BERT 模型生成的句子向量之间的余弦相似度。\n```python\nsentence1 = \"我喜欢这部电影！\"\nsentence2 = \"这部电影太棒了！\"\nsentence3 = \"我讨厌这部电影。\"\n\n# 使用 BERT 模型获取句子的向量\nbert_sentence_emb1 = get_bert_sentence_emb(sentence1)\nbert_sentence_emb2 = get_bert_sentence_emb(sentence2)\nbert_sentence_emb3 = get_bert_sentence_emb(sentence3)\n\nprint(f\"'{sentence1}' 和 '{sentence2}' 的余弦相似度: {cosine_similarity([bert_sentence_emb1], [bert_sentence_emb2])[0][0]:.2f}\")\nprint(f\"'{sentence1}' 和 '{sentence3}' 的余弦相似度: {cosine_similarity([bert_sentence_emb1], [bert_sentence_emb3])[0][0]:.2f}\")\nprint(f\"'{sentence2}' 和 '{sentence3}' 的余弦相似度: {cosine_similarity([bert_sentence_emb2], [bert_sentence_emb3])[0][0]:.2f}\")\n```\n\n结果是：\n```plaintext\n'我喜欢这部电影！' 和 '这部电影太棒了！' 的余弦相似度: 0.93\n'我喜欢这部电影！' 和 '我讨厌这部电影。' 的余弦相似度: 0.94\n'这部电影太棒了！' 和 '我讨厌这部电影。' 的余弦相似度: 0.89\n```\n\n很明显，前两个句子语义相近，并且与第三个句子语义相反。但是使用 BERT 模型的结果却是三个句子语义相近。\n\n最后看看 bge_m3模型的效果如何：\n```python\n# 使用 bge_m3 模型获取句子的向量\nbgem3_sentence_emb1 = get_bgem3_sentence_emb(sentence1)\nbgem3_sentence_emb2 = get_bgem3_sentence_emb(sentence2)\nbgem3_sentence_emb3 = get_bgem3_sentence_emb(sentence3)\n\nprint(f\"'{sentence1}' 和 '{sentence2}' 的余弦相似度: {cosine_similarity([bgem3_sentence_emb1], [bgem3_sentence_emb2])[0][0]:.2f}\")\nprint(f\"'{sentence1}' 和 '{sentence3}' 的余弦相似度: {cosine_similarity([bgem3_sentence_emb1], [bgem3_sentence_emb3])[0][0]:.2f}\")\nprint(f\"'{sentence2}' 和 '{sentence3}' 的余弦相似度: {cosine_similarity([bgem3_sentence_emb2], [bgem3_sentence_emb3])[0][0]:.2f}\")\n```\n\n结果是：\n```plaintext\n'我喜欢这部电影！' 和 '这部电影太棒了！' 的余弦相似度: 0.86\n'我喜欢这部电影！' 和 '我讨厌这部电影。' 的余弦相似度: 0.65\n'这部电影太棒了！' 和 '我讨厌这部电影。' 的余弦相似度: 0.57\n```\n\n从余弦相似度可以看出，前两个句子语义相近，和第三个句子语义较远。看来 bge_m3 模型确实可以捕捉句子中的上下文信息。\n\n## 藏宝图\n本文主要通过执行代码直观展示向量嵌入的原理和模型，如果你想进一步了解技术细节，这里有一些资料供你参考。\n\n### 词向量模型\nword2vect 模型论文：\n- [Efficient Estimation of Word Representations in Vector Space](https://arxiv.org/abs/1301.3781)\n- [Distributed Representations of Words and Phrases and their Compositionality](https://arxiv.org/abs/1310.4546)\n\n### 中文词向量模型\n- [Chinese-Word-Vectors](https://github.com/Embedding/Chinese-Word-Vectors) 项目提供了上百种预训练的中文词向量，这些词向量是基于不同的表征、上下文特征和语料库训练的，可以用于各种中文自然语言处理任务。\n-  [腾讯 AI Lab 中英文词和短语的嵌入语料库](https://ai.tencent.com/ailab/nlp/en/embedding.html)\n-  [word2vec-Chinese](https://github.com/lzhenboy/word2vec-Chinese) 介绍了如何训练中文 Word2Vec 词向量模型。\n \n### BERT 模型\nBERT 模型论文：\n-  [BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding](https://arxiv.org/abs/1810.04805)\n- [ColBERT: Efficient and Effective Passage Search via Contextualized Late Interaction over BERT](https://arxiv.org/abs/2004.12832)\n\nBERT 模型的 GitHub：[bert](https://github.com/google-research/bert)\n\n介绍 ColBERT 模型的博客：[Exploring ColBERT: A Token-Level Embedding and Ranking Model for Efficient Similarity Search](https://zilliz.com/learn/explore-colbert-token-level-embedding-and-ranking-model-for-similarity-search)\n\n### bge_m3 模型\n介绍 bge_m3模型的博客：[Exploring BGE-M3 and Splade: Two Machine Learning Models for Generating Sparse Embeddings](https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings#BERT-The-Foundation-Model-for-BGE-M3-and-Splade)\n\n### 注意力模型\n注意力模型论文：[Attention Is All You Need](https://arxiv.org/abs/1706.03762)\n\n### 模型库 \n-  [gensim](https://radimrehurek.com/gensim/) 包含了 word2vec 模型和 GloVe（Global Vectors for Word Representation）模型。\n- [Transformers](https://huggingface.co/transformers/) 是 Hugging Face 开发的一个开源库，专门用于自然语言处理（NLP）任务，它提供了大量预训练的 Transformer 模型，如 BERT、GPT、T5 等，并且支持多种语言和任务。\n- [Chinese-BERT-wwm](https://github.com/ymcui/Chinese-BERT-wwm) 是哈工大讯飞联合实验室（HFL）发布的中文 BERT 模型。\n- [pymilvus.model](https://milvus.io/docs/embeddings.md) 是 PyMilvus 客户端库的一个子包，提供多种嵌入模型的封装，用于生成向量嵌入，简化了文本转换过程。\n\n## 注释\n[^1]: 严格来说，“目标词”不是单词而是“token”。token 是组成句子的基本单元。对于英文来说，token可以简单理解为单词，还可能是子词（subword）或者标点符号，比如“unhappiness” 可能会被分割成“un”和“happiness“。对于汉字来说，则是字、词或者短语，汉字不会像英文单词那样被分割。","categories":["向量数据库","原理探秘"]},{"title":"如何假装文艺青年，怎么把大白话“变成”古诗词？","url":"/2024/09/16/如何假装文艺青年，怎么把大白话“变成”古诗词？/","content":"\n午后细雨绵绵，你独倚窗边，思绪万千，于是拿出手机，想发一条朋友圈抒发情怀，随便展示一下文采。奈何好不容易按出几个字，又全部删除。“今天的雨好大”展示不出你的文采。你灵机一动，如果有一个搜索引擎，能搜索出和“今天的雨好大”意思相近的古诗词，岂不妙哉！\n\n使用向量数据库就可以实现，代码还不到100行，一起来试试吧。我们会从零开始安装向量数据库 Milvus，向量化古诗词数据集，然后创建集合，导入数据，创建索引，最后实现语义搜索功能。\n\n>本文首发于 Zilliz 公众号。文中代码的 Notebook 在[这里](https://pan.baidu.com/s/1Su0U65G6ZXXuzUy8VO3_cA?pwd=esca)下载。\n\n## 0 准备工作\n首先安装向量数据库 Milvus。因为 Milvus 是运行在 docker 中的，所以需要先安装 Docker Desktop。MacOS 系统安装方法：[Install Docker Desktop on Mac](https://docs.docker.com/desktop/install/mac-install/) ，Windows 系统安装方法：[Install Docker Desktop on Windows](https://docs.docker.com/desktop/install/windows-install/)\n\n然后安装 Milvus。Milvus 版本：>=2.5.0\n下载安装脚本：\n```shell\ncurl -sfL https://raw.githubusercontent.com/milvus-io/milvus/master/scripts/standalone_embed.sh -o standalone_embed.sh\n```\n\n运行 Milvus：\n```shell\nbash standalone_embed.sh start\n```\n\n安装依赖。pymilvus >= 2.5.0\n```shell\npip install pymilvus==2.5.0 \"pymilvus[model]\" torch \n```\n\n下载古诗词数据集[^1] TangShi.json。它的格式是这样的：\n\n```json\n[\n\t{\n\t\t\"author\": \"太宗皇帝\",\n\t\t\"paragraphs\": [\n\t\t\t\"秦川雄帝宅，函谷壮皇居。\"\n\t\t],\n\t\t\"title\": \"帝京篇十首 一\",\n\t\t\"id\": 20000001,\n\t\t\"type\": \"唐诗\"\n\t},\n\t...\n]\n```\n\n准备就绪，正式开始啦。\n## 1 向量化文本\n为了实现语义搜索，我们需要先把文本向量化。你可以理解为把不同类型的信息（如文字、图像、声音）翻译成计算机可以理解的数字语言。计算机理解了，才能帮你找到语义相近的诗句。\n\n先定义两个函数，一个用来初始化嵌入模型（也就是用来向量化的模型）的实例，另一个是调用嵌入模型的实例，把输入的文档向量化。\n\n初始化嵌入模型的实例：\n```python\nfrom tqdm import tqdm\nimport torch\nfrom pymilvus.model.hybrid import BGEM3EmbeddingFunction\n\n# 初始化嵌入模型的实例\ndef init_embedding_model():\n    # 检查是否有可用的CUDA设备\n    device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\n    # 根据设备选择是否使用fp16\n    use_fp16 = device.startswith(\"cuda\")\n    # 创建嵌入模型实例\n    bge_m3_ef = BGEM3EmbeddingFunction(\n        model_name=\"BAAI/bge-m3\",\n        device=device,\n        use_fp16=use_fp16\n    )\n    return bge_m3_ef\n\nbge_m3_ef = init_embedding_model()\n```\n\n向量化文档：\n```python\n# 把文档向量化\ndef vectorize_docs(docs, encoder):\n    # 验证参数是否符合要求\n    if encoder is None:\n        raise ValueError(\"嵌入模型未初始化。\")\n    if not (isinstance(docs, list) and all(isinstance(text, str) for text in docs)):\n        raise ValueError(\"docs必须为字符串列表。\")\n    return encoder.encode_documents(docs)\n```\n\n准备好后，我们就可以向量化整个数据集了。首先读取数据集 TangShi.json 中的数据，把其中的 paragraphs 字段向量化，然后写入 TangShi_vector.json 文件。如果你是第一次使用 Milvus，运行下面的代码时还会安装必要的依赖。\n\n```python\nimport json\n# 读取 json 文件，把paragraphs字段向量化\nwith open(\"TangShi.json\", 'r', encoding='utf-8') as file:\n\tdata_list = json.load(file)\n\tdocs = [data['paragraphs'][0] for data in data_list]\n\n# 向量化文本数据\nvectors = vectorize_docs(docs, bge_m3_ef)\n\n# 将向量添加到原始文本中\nfor data, vector in zip(data_list, vectors['dense']):\n    # 将 NumPy 数组转换为 Python 的普通列表\n\tdata['vector'] = vector.tolist()\n\n# 将更新后的文本内容写入新的json文件\nwith open(\"TangShi_vector.json\", 'w', encoding='utf-8') as outfile:\n\tjson.dump(data_list, outfile, ensure_ascii=False, indent=4)\n```\n\n如果一切顺利，你会得到 TangShi_vector.json 文件，它增加了 vector 字段，它的值是一个字符串列表，也就是“向量”。\n\n```json\n[\n\t{\n\t\t\"author\": \"太宗皇帝\",\n\t\t\"paragraphs\": [\n\t\t\t\"秦川雄帝宅，函谷壮皇居。\"\n\t\t],\n\t\t\"title\": \"帝京篇十首 一\",\n\t\t\"id\": 20000001,\n\t\t\"type\": \"唐诗\",\n\t\t\"vector\": [\n\t\t\t0.005114779807627201,\n\t\t\t0.033538609743118286,\n\t\t\t0.020395483821630478,\n\t\t\t...\n\t\t]\n\t},\n\t{\n\t\t\"author\": \"太宗皇帝\",\n\t\t\"paragraphs\": [\n\t\t\t\"绮殿千寻起，离宫百雉余。\"\n\t\t],\n\t\t\"title\": \"帝京篇十首 一\",\n\t\t\"id\": 20000002,\n\t\t\"type\": \"唐诗\",\n\t\t\"vector\": [\n\t\t\t-0.06334448605775833,\n\t\t\t0.0017451602034270763,\n\t\t\t-0.0010646708542481065,\n\t\t\t...\n\t\t]\n\t},\n\t...\n]\n```\n\n## 2 创建集合\n接下来我们要把向量数据导入向量数据库。当然，我们得先在向量数据库中创建一个集合，用来容纳向量数据。\n```python\n# 创建milvus_client实例\nfrom pymilvus import MilvusClient, DataType\n\nmilvus_client = MilvusClient(uri=\"http://localhost:19530\")\n# 指定集合名称\ncollection_name = \"TangShi\"\n```\n\n为了避免向量数据库中存在同名集合，产生干扰，创建集合前先删除同名集合。\n```python\n# 检查同名集合是否存在，如果存在则删除\nif milvus_client.has_collection(collection_name):\n    print(f\"集合 {collection_name} 已经存在\")\n    try:\n        # 删除同名集合\n        milvus_client.drop_collection(collection_name)\n        print(f\"删除集合：{collection_name}\")\n    except Exception as e:\n        print(f\"删除集合时出现错误: {e}\")\n```\n\n我们把数据填入 excel 表格前，需要先设计好表头，规定有哪些字段，各个字段的数据类型是怎样的。向量数据库也是一样，它的“表头”就是 schema，模式。\n\n```python\nfrom pymilvus import DataType\n\n# 创建集合模式\nschema = MilvusClient.create_schema(\n    auto_id=False,\n    enable_dynamic_field=True,\n    description=\"TangShi\"\n)\n\n# 添加字段到schema\nschema.add_field(field_name=\"id\", datatype=DataType.INT64, is_primary=True)\nschema.add_field(field_name=\"vector\", datatype=DataType.FLOAT_VECTOR, dim=1024)\nschema.add_field(field_name=\"title\", datatype=DataType.VARCHAR, max_length=1024)\nschema.add_field(field_name=\"author\", datatype=DataType.VARCHAR, max_length=256)\nschema.add_field(field_name=\"paragraphs\", datatype=DataType.VARCHAR, max_length=10240)\nschema.add_field(field_name=\"type\", datatype=DataType.VARCHAR, max_length=128)\n```\n\n模式创建好了，接下来就可以创建集合了。\n```python\n# 创建集合\ntry:\n    milvus_client.create_collection(\n        collection_name=collection_name,\n        schema=schema,\n        shards_num=2\n    )\n    print(f\"开始创建集合：{collection_name}\")\nexcept Exception as e:\n    print(f\"创建集合的过程中出现了错误: {e}\")\n```\n\n## 3 入库\n接下来把文件导入到 Milvus。\n```python\n# 读取和处理文件\nwith open(\"TangShi_vector.json\", 'r') as file:\n    data = json.load(file)\n    # paragraphs的值是列表，需要获取列表中的字符串，以符合Milvus插入数据的要求\n    for item in data:\n        item[\"paragraphs\"] = item[\"paragraphs\"][0]\n\n# 将数据插入集合\nprint(f\"正在将数据插入集合：{collection_name}\")\nres = milvus_client.insert(\n    collection_name=collection_name,\n    data=data\n)\n```\n\n导入成功了吗？我们来验证下。\n```python\nprint(f\"插入的实体数量: {res['insert_count']}\")\n```\n\n返回插入实体的数量，看来是成功了。\n```shell\n插入的实体数量: 4307\n```\n\n## 4 创建索引\n向量已经导入 Milvus，现在可以搜索了吗？别急，为了提高搜索效率，我们还需要创建索引。什么是索引？一些大部头图书的最后，一般都会有索引，它列出了书中出现的关键术语以及对应的页码，帮助你快速找到它们的位置。如果没有索引，那就只能用笨方法，从第一页开始一页一页往后找了。\n\n![图片来源：自己拍的《英国皇家园艺学会植物繁育手册：用已有植物打造完美新植物》](https://picgo233.oss-cn-hangzhou.aliyuncs.com/img/202408232208878.jpeg)\n图片来源：自己拍的《英国皇家园艺学会植物繁育手册：用已有植物打造完美新植物》\n\nMilvus 的索引也是如此。如果不创建索引，虽然也可以搜索，但是速度很慢，它会逐一比较查询向量与数据库中每一个向量，通过指定方法计算出两个向量之间的 **距离**，找出距离最近的几个向量。而创建索引之后，搜索速度会大大提升。\n\n索引有不同的类型，适合不同的场景使用，我们以后会详细讨论这个问题。这里我们使用 IVF_FLAT。另外，计算**距离**的方法也有多种，我们使用 IP，也就是计算两个向量的内积。这些都是索引的参数，我们先创建这些参数。\n\n```python\n# 创建IndexParams对象，用于存储索引的各种参数\nindex_params = client.prepare_index_params()\n# 设置索引名称\nvector_index_name = \"vector_index\"\n# 设置索引的各种参数\nindex_params.add_index(\n\t# 指定为\"vector\"字段创建索引\n\tfield_name=\"vector\",\n\t# 设置索引类型\n\tindex_type=\"IVF_FLAT\",\n\t# 设置度量类型\n\tmetric_type=\"IP\",\n\t# 设置索引聚类中心的数量\n\tparams={\"nlist\": 128},\n\t# 指定索引名称\n\tindex_name=vector_index_name\n)\n```\n\n索引参数创建好了，现在终于可以创建索引了。\n```python\nprint(f\"开始创建索引：{vector_index_name}\")\n\n# 创建索引\nclient.create_index(\n\t# 指定为哪个集合创建索引\n\tcollection_name=collection_name,\n\t# 使用前面创建的索引参数创建索引\n\tindex_params=index_params\n)\n```\n\n我们来验证下索引是否创建成功了。\n```python\nindexes = client.list_indexes(\n\tcollection_name=collection_name\n)\nprint(f\"列出创建的索引：{indexes}\")\n```\n\n返回了包含索引名称的列表，索引名称 vector_index 正是我们之前创建的。\n```shell\n列出创建的索引：['vector_index']\n```\n  \n再来查看下索引的详情。\n```python\n# 查看索引详情\nindex_details = client.describe_index(\n\tcollection_name=collection_name,\n\t# 指定索引名称，这里假设使用第一个索引\n\tindex_name=\"vector_index\"\n)\nprint(f\"索引vector_index详情：{index_details}\")\n```\n\n返回了一个包含索引详细信息的字典，可以我们之前设置的索引参数，比如 nlist，index_type 和 metric_type 等等。\n```plaintext\n索引vector_index详情：{'nlist': '128', 'index_type': 'IVF_FLAT', 'metric_type': 'IP', 'field_name': 'vector', 'index_name': 'vector_index', 'total_rows': 0, 'indexed_rows': 0, 'pending_index_rows': 0, 'state': 'Finished'}\n```\n\n## 5 加载索引\n索引创建成功了，现在可以搜索了吗？等等，我们还需要把集合中的数据和索引，从硬盘加载到内存中。因为在内存中搜索更快。\n```python\nprint(f\"正在加载集合：{collection_name}\")\nclient.load_collection(collection_name=collection_name)\n```\n\n加载完成了，仍然验证下。\n```python\nprint(client.get_load_state(collection_name=collection_name))\n```\n\n返回加载状态 Loaded，没问题，加载完成。\n```shell\n{'state': <LoadState: Loaded>}\n```\n\n## 6 搜索\n经过前面的一系列准备，现在我们终于可以回到开头的问题了，用现代白话文搜索语义相似的古诗词。\n\n首先，把我们要搜索的现代白话文“翻译”成向量。\n```python\n# 获取查询向量\nquery = \"今天的雨好大\"\nquery_vectors = [vectorize_docs([query], bge_m3_ef)['dense'][0].tolist()]\n```\n\n然后，设置搜索参数，告诉 Milvus 怎么搜索。\n```python\n# 设置搜索参数\nsearch_params = {\n\t# 设置度量类型\n\t\"metric_type\": \"IP\",\n\t# 指定在搜索过程中要查询的聚类单元数量，增加nprobe值可以提高搜索精度，但会降低搜索速度\n\t\"params\": {\"nprobe\": 16}\n}\n```\n\n最后，我们还得告诉它怎么输出结果。\n```python\n# 指定返回搜索结果的数量\nlimit = 3\n# 指定返回的字段\noutput_fields = [\"author\", \"title\", \"paragraphs\"]\n```\n\n一切就绪，让我们开始搜索吧！\n```python\nres1 = milvus_client.search(\n    collection_name=collection_name,\n    # 指定查询向量\n    data=query_vectors,\n    # 指定搜索的字段\n    anns_field=\"vector\",\n    # 设置搜索参数\n    search_params=search_params,\n    limit=limit,\n    output_fields=output_fields\n)\nprint(res1)\n```\n\n得到下面的结果：\n```plaintext\ndata: [\n    \"[\n        {\n            'id': 20002740,\n            'distance': 0.6542239189147949,\n            'entity': {\n                'title': '郊庙歌辞 享太庙乐章 大明舞',\n                'paragraphs': '旱望春雨，云披大风。',\n                'author': '张说'\n            }\n        },\n        {\n            'id': 20001658,\n            'distance': 0.6228379011154175,\n            'entity': {\n                'title': '三学山夜看圣灯',\n                'paragraphs': '细雨湿不暗，好风吹更明。',\n                'author': '蜀太妃徐氏'\n            }\n        },\n        {\n            'id': 20003360,\n            'distance': 0.6123768091201782,\n            'entity': {\n                'title': '郊庙歌辞 汉宗庙乐舞辞 积善舞',\n                'paragraphs': '云行雨施，天成地平。',\n                'author': '张昭'\n            }\n        }\n    ]\"\n]\n```\n\n在搜索结果中，id、title 等字段我们都了解了，只有 distance 是新出现的。它指的是搜索结果与查询向量之间的“距离”，具体含义和度量类型有关。我们使用的度量类型是 IP 内积，数字越大表示搜索结果和查询向量越接近。\n\n为了增加可读性，我们写一个输出函数：\n```python\n# 打印向量搜索结果\ndef print_vector_results(res):\n    # hit是搜索结果中的每一个匹配的实体\n    res = [hit[\"entity\"] for hit in res[0]]\n    for item in res:\n        print(f\"title: {item['title']}\")\n        print(f\"author: {item['author']}\")\n        print(f\"paragraphs: {item['paragraphs']}\")\n        print(\"-\"*50)   \n    print(f\"数量：{len(res)}\")\n```\n\n重新输出结果：\n```python\nprint_vector_results(res1)\n```\n\n这下搜索结果容易阅读了。\n```shell\ntitle: 郊庙歌辞 享太庙乐章 大明舞\nauthor: 张说\nparagraphs: 旱望春雨，云披大风。\n--------------------------------------------------\ntitle: 三学山夜看圣灯\nauthor: 蜀太妃徐氏\nparagraphs: 细雨湿不暗，好风吹更明。\n--------------------------------------------------\ntitle: 郊庙歌辞 汉宗庙乐舞辞 积善舞\nauthor: 张昭\nparagraphs: 云行雨施，天成地平。\n--------------------------------------------------\n数量：3\n```\n\n如果你不想限制搜索结果的数量，而是返回所有质量符合要求的搜索结果，可以修改搜索参数。比如，在搜索参数中增加 radius 和 range_filter 参数，它们限制了距离 distance 的范围在0.55到1之间。\n```python\n# 修改搜索参数，设置距离的范围\nsearch_params = {\n    \"metric_type\": \"IP\",\n    \"params\": {\n        \"nprobe\": 16,\n        \"radius\": 0.55,\n        \"range_filter\": 1.0\n    }\n}\n```\n\n然后调整搜索代码，删除 limit 参数。\n```python\n\nres2 = milvus_client.search(\n    collection_name=collection_name,\n    # 指定查询向量\n    data=query_vectors,\n    # 指定搜索的字段\n    anns_field=\"vector\",\n    # 设置搜索参数\n    search_params=search_params,\n    # 删除limit参数\n    output_fields=output_fields\n)\n\nprint(res2)\n```\n\n可以看到，输出结果的 distance 都大于0.55。\n```plaintext\ndata: [\n    \"[\n        {\n            'id': 20002740,\n            'distance': 0.6542239189147949,\n            'entity': {\n                'author': '张说',\n                'title': '郊庙歌辞 享太庙乐章 大明舞',\n                'paragraphs': '旱望春雨，云披大风。'\n            }\n        },\n        {\n            'id': 20001658,\n            'distance': 0.6228379011154175,\n            'entity': {\n                'author': '蜀太妃徐氏',\n                'title': '三学山夜看圣灯',\n                'paragraphs': '细雨湿不暗，好风吹更明。'\n            }\n        },\n        ...\n        {\n\t        'id': 20001375, \n\t        'distance': 0.5891480445861816, \n\t        'entity': {\n\t\t        'author': '上官昭容', \n\t\t        'title': '游长宁公主流杯池二十五首 二十', \n\t\t        'paragraphs': '瀑溜晴疑雨，丛篁昼似昏。'\n\t\t    }\n\t\t}\n    ]\"\n]\n```\n\n也许你还想知道你最喜欢的李白，有没有和你一样感慨今天的雨真大，没问题，我们增加filter参数就可以了。\n```python\n# 通过表达式过滤字段author，筛选出字段“author”的值为“李白”的结果\nfilter = f\"author == '李白'\"\n\nres3 = client.search(\n\tcollection_name=collection_name,\n\t# 指定查询向量\n\tdata=query_vectors,\n\t# 指定搜索的字段\n\tanns_field=\"vector\",\n\t# 设置搜索参数\n\tsearch_params=search_params,\n\t# 通过表达式实现标量过滤，筛选结果\n\tfilter=filter,\n\t# 指定返回搜索结果的数量\n\tlimit=limit,\n\t# 指定返回的字段\n\toutput_fields=output_fields\n)\nprint(res3)\n```\n\n返回的结果为空值。\n```python\ndata: ['[]'] \n```\n\n这是因为我们前面设置了 distance 的范围在0.55到1之间，放大范围可以获得更多结果。把 \"radius\" 的值修改为0.2，再次运行命令，让我们看看李白是怎么感慨的。\n```plaintext\ndata: [\n    \"[\n        {\n            'id': 20004246,\n            'distance': 0.46472394466400146,\n            'entity': {\n                'author': '李白',\n                'title': '横吹曲辞 关山月',\n                'paragraphs': '明月出天山，苍茫云海间。'\n            }\n        },\n        {\n            'id': 20003707,\n            'distance': 0.4347272515296936,\n            'entity': {\n                'author': '李白',\n                'title': '鼓吹曲辞 有所思',\n                'paragraphs': '海寒多天风，白波连山倒蓬壶。'\n            }\n        },\n        {\n            'id': 20003556,\n            'distance': 0.40778297185897827,\n            'entity': {\n                'author': '李白',\n                'title': '鼓吹曲辞 战城南',\n                'paragraphs': '去年战桑干源，今年战葱河道。'\n            }\n        }\n    ]\"\n]\n```\n\n我们观察搜索结果发现， distance 在0.4左右，小于之前设置的0.55，所以被排除了。另外，distance 数值较小，说明搜索结果并不是特别接近查询向量，而这几句诗词的确和“雨”的关系比较远。\n\n如果你希望搜索结果中直接包含“雨”字，可以使用 query 方法做标量搜索。\n```python\n# paragraphs字段包含“雨”字\nfilter = f\"paragraphs like '%雨%'\"\n\nres4 = client.query(\n\tcollection_name=collection_name,\n\tfilter=filter,\n\toutput_fields=output_fields,\n\tlimit=limit\n)\nprint(res4)\n```\n\n标量查询的代码更简单，因为它免去了和向量搜索相关的参数，比如查询向量 data，指定搜索字段的 anns_field 和搜索参数 search_params，搜索参数只有 filter 。\n\n观察搜索结果发现，标量搜索结果的数据结构少了一个 “[]”，我们在提取具体字段时需要注意这一点。\n```plaintext\ndata: [\n    \"{\n        \"author\": \"太宗皇帝\",\n        \"title\": \"咏雨\",\n        \"paragraphs\": \"罩云飘远岫，喷雨泛长河。\",\n        \"id\": 20000305\n    },\n    {\n        \"author\": \"太宗皇帝\",\n        \"title\": \"咏雨\",\n        \"paragraphs\": \"和气吹绿野，梅雨洒芳田。\",\n        \"id\": 20000402\n    },\n    {\n        \"author\": \"太宗皇帝\",\n        \"title\": \"赋得花庭雾\",\n        \"paragraphs\": \"还当杂行雨，髣髴隐遥空。\",\n        \"id\": 20000421\n    }\"\n]\n```\n\nfilter 表达式还有丰富的用法，比如同时搜索两个字段，author 字段指定为 “杜甫”，同时 paragraphs 字段仍然要求包含“雨”字：\n```python\nfilter = f\"author == '杜甫' && paragraphs like '%雨%'\"\n\nres5 = client.query(\n\tcollection_name=collection_name,\n\tfilter=filter,\n\toutput_fields=output_fields,\n\tlimit=limit\n)\nprint(res5)\n```\n\n返回杜甫含有“雨”字的诗句：\n```plaintext\ndata: [\n\t\"{\n\t\t'title': '横吹曲辞 前出塞九首 七', \n\t\t'paragraphs': '驱马天雨雪，军行入高山。', \n\t\t'id': 20004039, \n\t\t'author': '杜甫'\n\t}\"\n] \n```\n\n更多标量搜索的表达式可以参考[Get & Scalar Query](https://milvus.io/docs/get-and-scalar-query.md#Use-Basic-Operators)。\n\n## 总结\n可能这样的搜索结果并没有让你很满意，这里面有多个原因。首先，数据集太小了。只有4000多个句子，语义更接近的句子可能没有包含其中。其次，嵌入模型虽然支持中文，但是古诗词并不是它的专长。这就好像你找了个翻译帮你和老外交流，翻译虽然懂普通话，但是你满嘴四川方言，翻译也只能也蒙带猜，翻译质量可想而知。\n\n如果你希望优化搜索功能，可以在 [chinese-poetry](https://github.com/BushJiang/chinese-poetry) 下载完整的古诗词数据集，再找找专门用于古诗词的嵌入模型，相信搜索效果会有较大提升。\n\n另外，我在以上代码的基础上，开发了一个命令行应用，有兴趣可以玩玩：[语义搜索古诗词](https://github.com/BushJiang/searchPoems)\n\n## 注释\n[^1]:古诗词数据集来自 [chinese-poetry](https://github.com/BushJiang/chinese-poetry)，数据结构做了调整。","categories":["向量数据库","趣味应用"]}]